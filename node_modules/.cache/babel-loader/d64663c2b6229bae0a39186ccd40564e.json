{"ast":null,"code":"import _toConsumableArray from \"/Users/mac/Documents/GitHub/deepfake-demo/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport boolbase from \"boolbase\";\nimport { isTraversal } from \"../sort.js\";\n/** Used as a placeholder for :has. Will be replaced with the actual element. */\nexport var PLACEHOLDER_ELEMENT = {};\nexport function ensureIsTag(next, adapter) {\n  if (next === boolbase.falseFunc) return boolbase.falseFunc;\n  return function (elem) {\n    return adapter.isTag(elem) && next(elem);\n  };\n}\nexport function getNextSiblings(elem, adapter) {\n  var siblings = adapter.getSiblings(elem);\n  if (siblings.length <= 1) return [];\n  var elemIndex = siblings.indexOf(elem);\n  if (elemIndex < 0 || elemIndex === siblings.length - 1) return [];\n  return siblings.slice(elemIndex + 1).filter(adapter.isTag);\n}\nfunction copyOptions(options) {\n  // Not copied: context, rootFunc\n  return {\n    xmlMode: !!options.xmlMode,\n    lowerCaseAttributeNames: !!options.lowerCaseAttributeNames,\n    lowerCaseTags: !!options.lowerCaseTags,\n    quirksMode: !!options.quirksMode,\n    cacheResults: !!options.cacheResults,\n    pseudos: options.pseudos,\n    adapter: options.adapter,\n    equals: options.equals\n  };\n}\nvar is = function is(next, token, options, context, compileToken) {\n  var func = compileToken(token, copyOptions(options), context);\n  return func === boolbase.trueFunc ? next : func === boolbase.falseFunc ? boolbase.falseFunc : function (elem) {\n    return func(elem) && next(elem);\n  };\n};\n/*\n * :not, :has, :is, :matches and :where have to compile selectors\n * doing this in src/pseudos.ts would lead to circular dependencies,\n * so we add them here\n */\nexport var subselects = {\n  is: is,\n  /**\n   * `:matches` and `:where` are aliases for `:is`.\n   */\n  matches: is,\n  where: is,\n  not: function not(next, token, options, context, compileToken) {\n    var func = compileToken(token, copyOptions(options), context);\n    return func === boolbase.falseFunc ? next : func === boolbase.trueFunc ? boolbase.falseFunc : function (elem) {\n      return !func(elem) && next(elem);\n    };\n  },\n  has: function has(next, subselect, options, _context, compileToken) {\n    var adapter = options.adapter;\n    var opts = copyOptions(options);\n    opts.relativeSelector = true;\n    var context = subselect.some(function (s) {\n      return s.some(isTraversal);\n    }) ?\n    // Used as a placeholder. Will be replaced with the actual element.\n    [PLACEHOLDER_ELEMENT] : undefined;\n    var compiled = compileToken(subselect, opts, context);\n    if (compiled === boolbase.falseFunc) return boolbase.falseFunc;\n    var hasElement = ensureIsTag(compiled, adapter);\n    // If `compiled` is `trueFunc`, we can skip this.\n    if (context && compiled !== boolbase.trueFunc) {\n      /*\n       * `shouldTestNextSiblings` will only be true if the query starts with\n       * a traversal (sibling or adjacent). That means we will always have a context.\n       */\n      var _compiled$shouldTestN = compiled.shouldTestNextSiblings,\n        shouldTestNextSiblings = _compiled$shouldTestN === void 0 ? false : _compiled$shouldTestN;\n      return function (elem) {\n        if (!next(elem)) return false;\n        context[0] = elem;\n        var childs = adapter.getChildren(elem);\n        var nextElements = shouldTestNextSiblings ? [].concat(_toConsumableArray(childs), _toConsumableArray(getNextSiblings(elem, adapter))) : childs;\n        return adapter.existsOne(hasElement, nextElements);\n      };\n    }\n    return function (elem) {\n      return next(elem) && adapter.existsOne(hasElement, adapter.getChildren(elem));\n    };\n  }\n};","map":{"version":3,"sources":["pseudo-selectors/subselects.ts"],"names":[],"mappings":"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","sourceRoot":"https://raw.githubusercontent.com/fb55/css-select/0f0725a9dfeddd2fdb54eda9656cdbab5bbf6be6/src/","sourcesContent":["import boolbase from \"boolbase\";\nimport { isTraversal } from \"../sort.js\";\n/** Used as a placeholder for :has. Will be replaced with the actual element. */\nexport const PLACEHOLDER_ELEMENT = {};\nexport function ensureIsTag(next, adapter) {\n    if (next === boolbase.falseFunc)\n        return boolbase.falseFunc;\n    return (elem) => adapter.isTag(elem) && next(elem);\n}\nexport function getNextSiblings(elem, adapter) {\n    const siblings = adapter.getSiblings(elem);\n    if (siblings.length <= 1)\n        return [];\n    const elemIndex = siblings.indexOf(elem);\n    if (elemIndex < 0 || elemIndex === siblings.length - 1)\n        return [];\n    return siblings.slice(elemIndex + 1).filter(adapter.isTag);\n}\nfunction copyOptions(options) {\n    // Not copied: context, rootFunc\n    return {\n        xmlMode: !!options.xmlMode,\n        lowerCaseAttributeNames: !!options.lowerCaseAttributeNames,\n        lowerCaseTags: !!options.lowerCaseTags,\n        quirksMode: !!options.quirksMode,\n        cacheResults: !!options.cacheResults,\n        pseudos: options.pseudos,\n        adapter: options.adapter,\n        equals: options.equals,\n    };\n}\nconst is = (next, token, options, context, compileToken) => {\n    const func = compileToken(token, copyOptions(options), context);\n    return func === boolbase.trueFunc\n        ? next\n        : func === boolbase.falseFunc\n            ? boolbase.falseFunc\n            : (elem) => func(elem) && next(elem);\n};\n/*\n * :not, :has, :is, :matches and :where have to compile selectors\n * doing this in src/pseudos.ts would lead to circular dependencies,\n * so we add them here\n */\nexport const subselects = {\n    is,\n    /**\n     * `:matches` and `:where` are aliases for `:is`.\n     */\n    matches: is,\n    where: is,\n    not(next, token, options, context, compileToken) {\n        const func = compileToken(token, copyOptions(options), context);\n        return func === boolbase.falseFunc\n            ? next\n            : func === boolbase.trueFunc\n                ? boolbase.falseFunc\n                : (elem) => !func(elem) && next(elem);\n    },\n    has(next, subselect, options, _context, compileToken) {\n        const { adapter } = options;\n        const opts = copyOptions(options);\n        opts.relativeSelector = true;\n        const context = subselect.some((s) => s.some(isTraversal))\n            ? // Used as a placeholder. Will be replaced with the actual element.\n                [PLACEHOLDER_ELEMENT]\n            : undefined;\n        const compiled = compileToken(subselect, opts, context);\n        if (compiled === boolbase.falseFunc)\n            return boolbase.falseFunc;\n        const hasElement = ensureIsTag(compiled, adapter);\n        // If `compiled` is `trueFunc`, we can skip this.\n        if (context && compiled !== boolbase.trueFunc) {\n            /*\n             * `shouldTestNextSiblings` will only be true if the query starts with\n             * a traversal (sibling or adjacent). That means we will always have a context.\n             */\n            const { shouldTestNextSiblings = false } = compiled;\n            return (elem) => {\n                if (!next(elem))\n                    return false;\n                context[0] = elem;\n                const childs = adapter.getChildren(elem);\n                const nextElements = shouldTestNextSiblings\n                    ? [...childs, ...getNextSiblings(elem, adapter)]\n                    : childs;\n                return adapter.existsOne(hasElement, nextElements);\n            };\n        }\n        return (elem) => next(elem) &&\n            adapter.existsOne(hasElement, adapter.getChildren(elem));\n    },\n};\n//# sourceMappingURL=subselects.js.map"]},"metadata":{},"sourceType":"module"}