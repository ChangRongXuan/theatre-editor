{"ast":null,"code":"import _slicedToArray from \"/Users/mac/Documents/GitHub/deepfake-demo/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _createForOfIteratorHelper from \"/Users/mac/Documents/GitHub/deepfake-demo/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport { parse, SelectorType } from \"css-what\";\nimport boolbase from \"boolbase\";\nimport sortRules, { isTraversal } from \"./sort.js\";\nimport { compileGeneralSelector } from \"./general.js\";\nimport { ensureIsTag, PLACEHOLDER_ELEMENT } from \"./pseudo-selectors/subselects.js\";\n/**\n * Compiles a selector to an executable function.\n *\n * @param selector Selector to compile.\n * @param options Compilation options.\n * @param context Optional context for the selector.\n */\nexport function compile(selector, options, context) {\n  var next = compileUnsafe(selector, options, context);\n  return ensureIsTag(next, options.adapter);\n}\nexport function compileUnsafe(selector, options, context) {\n  var token = typeof selector === \"string\" ? parse(selector) : selector;\n  return compileToken(token, options, context);\n}\nfunction includesScopePseudo(t) {\n  return t.type === SelectorType.Pseudo && (t.name === \"scope\" || Array.isArray(t.data) && t.data.some(function (data) {\n    return data.some(includesScopePseudo);\n  }));\n}\nvar DESCENDANT_TOKEN = {\n  type: SelectorType.Descendant\n};\nvar FLEXIBLE_DESCENDANT_TOKEN = {\n  type: \"_flexibleDescendant\"\n};\nvar SCOPE_TOKEN = {\n  type: SelectorType.Pseudo,\n  name: \"scope\",\n  data: null\n};\n/*\n * CSS 4 Spec (Draft): 3.4.1. Absolutizing a Relative Selector\n * http://www.w3.org/TR/selectors4/#absolutizing\n */\nfunction absolutize(token, _ref, context) {\n  var adapter = _ref.adapter;\n  // TODO Use better check if the context is a document\n  var hasContext = !!(context === null || context === void 0 ? void 0 : context.every(function (e) {\n    var parent = adapter.isTag(e) && adapter.getParent(e);\n    return e === PLACEHOLDER_ELEMENT || parent && adapter.isTag(parent);\n  }));\n  var _iterator = _createForOfIteratorHelper(token),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var t = _step.value;\n      if (t.length > 0 && isTraversal(t[0]) && t[0].type !== SelectorType.Descendant) {\n        // Don't continue in else branch\n      } else if (hasContext && !t.some(includesScopePseudo)) {\n        t.unshift(DESCENDANT_TOKEN);\n      } else {\n        continue;\n      }\n      t.unshift(SCOPE_TOKEN);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n}\nexport function compileToken(token, options, context) {\n  var _a;\n  token.forEach(sortRules);\n  context = (_a = options.context) !== null && _a !== void 0 ? _a : context;\n  var isArrayContext = Array.isArray(context);\n  var finalContext = context && (Array.isArray(context) ? context : [context]);\n  // Check if the selector is relative\n  if (options.relativeSelector !== false) {\n    absolutize(token, options, finalContext);\n  } else if (token.some(function (t) {\n    return t.length > 0 && isTraversal(t[0]);\n  })) {\n    throw new Error(\"Relative selectors are not allowed when the `relativeSelector` option is disabled\");\n  }\n  var shouldTestNextSiblings = false;\n  var query = token.map(function (rules) {\n    if (rules.length >= 2) {\n      var _rules = _slicedToArray(rules, 2),\n        first = _rules[0],\n        second = _rules[1];\n      if (first.type !== SelectorType.Pseudo || first.name !== \"scope\") {\n        // Ignore\n      } else if (isArrayContext && second.type === SelectorType.Descendant) {\n        rules[1] = FLEXIBLE_DESCENDANT_TOKEN;\n      } else if (second.type === SelectorType.Adjacent || second.type === SelectorType.Sibling) {\n        shouldTestNextSiblings = true;\n      }\n    }\n    return compileRules(rules, options, finalContext);\n  }).reduce(reduceRules, boolbase.falseFunc);\n  query.shouldTestNextSiblings = shouldTestNextSiblings;\n  return query;\n}\nfunction compileRules(rules, options, context) {\n  var _a;\n  return rules.reduce(function (previous, rule) {\n    return previous === boolbase.falseFunc ? boolbase.falseFunc : compileGeneralSelector(previous, rule, options, context, compileToken);\n  }, (_a = options.rootFunc) !== null && _a !== void 0 ? _a : boolbase.trueFunc);\n}\nfunction reduceRules(a, b) {\n  if (b === boolbase.falseFunc || a === boolbase.trueFunc) {\n    return a;\n  }\n  if (a === boolbase.falseFunc || b === boolbase.trueFunc) {\n    return b;\n  }\n  return function combine(elem) {\n    return a(elem) || b(elem);\n  };\n}","map":{"version":3,"sources":["compile.ts"],"names":[],"mappings":"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","sourceRoot":"https://raw.githubusercontent.com/fb55/css-select/0f0725a9dfeddd2fdb54eda9656cdbab5bbf6be6/src/","sourcesContent":["import { parse, SelectorType } from \"css-what\";\nimport boolbase from \"boolbase\";\nimport sortRules, { isTraversal } from \"./sort.js\";\nimport { compileGeneralSelector } from \"./general.js\";\nimport { ensureIsTag, PLACEHOLDER_ELEMENT, } from \"./pseudo-selectors/subselects.js\";\n/**\n * Compiles a selector to an executable function.\n *\n * @param selector Selector to compile.\n * @param options Compilation options.\n * @param context Optional context for the selector.\n */\nexport function compile(selector, options, context) {\n    const next = compileUnsafe(selector, options, context);\n    return ensureIsTag(next, options.adapter);\n}\nexport function compileUnsafe(selector, options, context) {\n    const token = typeof selector === \"string\" ? parse(selector) : selector;\n    return compileToken(token, options, context);\n}\nfunction includesScopePseudo(t) {\n    return (t.type === SelectorType.Pseudo &&\n        (t.name === \"scope\" ||\n            (Array.isArray(t.data) &&\n                t.data.some((data) => data.some(includesScopePseudo)))));\n}\nconst DESCENDANT_TOKEN = { type: SelectorType.Descendant };\nconst FLEXIBLE_DESCENDANT_TOKEN = {\n    type: \"_flexibleDescendant\",\n};\nconst SCOPE_TOKEN = {\n    type: SelectorType.Pseudo,\n    name: \"scope\",\n    data: null,\n};\n/*\n * CSS 4 Spec (Draft): 3.4.1. Absolutizing a Relative Selector\n * http://www.w3.org/TR/selectors4/#absolutizing\n */\nfunction absolutize(token, { adapter }, context) {\n    // TODO Use better check if the context is a document\n    const hasContext = !!(context === null || context === void 0 ? void 0 : context.every((e) => {\n        const parent = adapter.isTag(e) && adapter.getParent(e);\n        return e === PLACEHOLDER_ELEMENT || (parent && adapter.isTag(parent));\n    }));\n    for (const t of token) {\n        if (t.length > 0 &&\n            isTraversal(t[0]) &&\n            t[0].type !== SelectorType.Descendant) {\n            // Don't continue in else branch\n        }\n        else if (hasContext && !t.some(includesScopePseudo)) {\n            t.unshift(DESCENDANT_TOKEN);\n        }\n        else {\n            continue;\n        }\n        t.unshift(SCOPE_TOKEN);\n    }\n}\nexport function compileToken(token, options, context) {\n    var _a;\n    token.forEach(sortRules);\n    context = (_a = options.context) !== null && _a !== void 0 ? _a : context;\n    const isArrayContext = Array.isArray(context);\n    const finalContext = context && (Array.isArray(context) ? context : [context]);\n    // Check if the selector is relative\n    if (options.relativeSelector !== false) {\n        absolutize(token, options, finalContext);\n    }\n    else if (token.some((t) => t.length > 0 && isTraversal(t[0]))) {\n        throw new Error(\"Relative selectors are not allowed when the `relativeSelector` option is disabled\");\n    }\n    let shouldTestNextSiblings = false;\n    const query = token\n        .map((rules) => {\n        if (rules.length >= 2) {\n            const [first, second] = rules;\n            if (first.type !== SelectorType.Pseudo ||\n                first.name !== \"scope\") {\n                // Ignore\n            }\n            else if (isArrayContext &&\n                second.type === SelectorType.Descendant) {\n                rules[1] = FLEXIBLE_DESCENDANT_TOKEN;\n            }\n            else if (second.type === SelectorType.Adjacent ||\n                second.type === SelectorType.Sibling) {\n                shouldTestNextSiblings = true;\n            }\n        }\n        return compileRules(rules, options, finalContext);\n    })\n        .reduce(reduceRules, boolbase.falseFunc);\n    query.shouldTestNextSiblings = shouldTestNextSiblings;\n    return query;\n}\nfunction compileRules(rules, options, context) {\n    var _a;\n    return rules.reduce((previous, rule) => previous === boolbase.falseFunc\n        ? boolbase.falseFunc\n        : compileGeneralSelector(previous, rule, options, context, compileToken), (_a = options.rootFunc) !== null && _a !== void 0 ? _a : boolbase.trueFunc);\n}\nfunction reduceRules(a, b) {\n    if (b === boolbase.falseFunc || a === boolbase.trueFunc) {\n        return a;\n    }\n    if (a === boolbase.falseFunc || b === boolbase.trueFunc) {\n        return b;\n    }\n    return function combine(elem) {\n        return a(elem) || b(elem);\n    };\n}\n//# sourceMappingURL=compile.js.map"]},"metadata":{},"sourceType":"module"}