{"ast":null,"code":"var _regeneratorRuntime = require(\"/Users/mac/Documents/GitHub/deepfake-demo/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _slicedToArray = require(\"/Users/mac/Documents/GitHub/deepfake-demo/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar _classCallCheck = require(\"/Users/mac/Documents/GitHub/deepfake-demo/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/mac/Documents/GitHub/deepfake-demo/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _defineProperty = require(\"/Users/mac/Documents/GitHub/deepfake-demo/node_modules/@babel/runtime/helpers/defineProperty.js\").default;\nvar _toArray = require(\"/Users/mac/Documents/GitHub/deepfake-demo/node_modules/@babel/runtime/helpers/toArray.js\").default;\nvar _toConsumableArray = require(\"/Users/mac/Documents/GitHub/deepfake-demo/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\nvar _createForOfIteratorHelper = require(\"/Users/mac/Documents/GitHub/deepfake-demo/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _marked = /*#__PURE__*/_regeneratorRuntime().mark(_iterateAndCountTicks),\n  _marked2 = /*#__PURE__*/_regeneratorRuntime().mark(_iterateOver);\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = function __defNormalProp(obj, key, value) {\n  return key in obj ? __defProp(obj, key, {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: value\n  }) : obj[key] = value;\n};\nvar __spreadValues = function __spreadValues(a, b) {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols) {\n    var _iterator = _createForOfIteratorHelper(__getOwnPropSymbols(b)),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var prop = _step.value;\n        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n  return a;\n};\nvar __spreadProps = function __spreadProps(a, b) {\n  return __defProps(a, __getOwnPropDescs(b));\n};\nvar __markAsModule = function __markAsModule(target) {\n  return __defProp(target, \"__esModule\", {\n    value: true\n  });\n};\nvar __export = function __export(target, all) {\n  __markAsModule(target);\n  for (var name in all) __defProp(target, name, {\n    get: all[name],\n    enumerable: true\n  });\n};\n\n// src/index.ts\n__export(exports, {\n  Atom: function Atom() {\n    return _Atom;\n  },\n  PointerProxy: function PointerProxy() {\n    return _PointerProxy;\n  },\n  Ticker: function Ticker() {\n    return _Ticker;\n  },\n  getPointerParts: function getPointerParts() {\n    return _getPointerParts;\n  },\n  isPointer: function isPointer() {\n    return _isPointer;\n  },\n  isPrism: function isPrism() {\n    return _isPrism;\n  },\n  iterateAndCountTicks: function iterateAndCountTicks() {\n    return _iterateAndCountTicks;\n  },\n  iterateOver: function iterateOver() {\n    return _iterateOver;\n  },\n  pointer: function pointer() {\n    return pointer_default;\n  },\n  pointerToPrism: function pointerToPrism() {\n    return _pointerToPrism;\n  },\n  prism: function prism() {\n    return prism_default;\n  },\n  val: function val() {\n    return _val;\n  }\n});\n\n// ../../node_modules/lodash-es/isArray.js\nvar isArray = Array.isArray;\nvar isArray_default = isArray;\n\n// ../../node_modules/lodash-es/_freeGlobal.js\nvar freeGlobal = typeof global == \"object\" && global && global.Object === Object && global;\nvar freeGlobal_default = freeGlobal;\n\n// ../../node_modules/lodash-es/_root.js\nvar freeSelf = typeof self == \"object\" && self && self.Object === Object && self;\nvar root = freeGlobal_default || freeSelf || Function(\"return this\")();\nvar root_default = root;\n\n// ../../node_modules/lodash-es/_Symbol.js\nvar Symbol2 = root_default.Symbol;\nvar Symbol_default = Symbol2;\n\n// ../../node_modules/lodash-es/_getRawTag.js\nvar objectProto = Object.prototype;\nvar hasOwnProperty = objectProto.hasOwnProperty;\nvar nativeObjectToString = objectProto.toString;\nvar symToStringTag = Symbol_default ? Symbol_default.toStringTag : void 0;\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n    tag = value[symToStringTag];\n  try {\n    value[symToStringTag] = void 0;\n    var unmasked = true;\n  } catch (e) {}\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\nvar getRawTag_default = getRawTag;\n\n// ../../node_modules/lodash-es/_objectToString.js\nvar objectProto2 = Object.prototype;\nvar nativeObjectToString2 = objectProto2.toString;\nfunction objectToString(value) {\n  return nativeObjectToString2.call(value);\n}\nvar objectToString_default = objectToString;\n\n// ../../node_modules/lodash-es/_baseGetTag.js\nvar nullTag = \"[object Null]\";\nvar undefinedTag = \"[object Undefined]\";\nvar symToStringTag2 = Symbol_default ? Symbol_default.toStringTag : void 0;\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === void 0 ? undefinedTag : nullTag;\n  }\n  return symToStringTag2 && symToStringTag2 in Object(value) ? getRawTag_default(value) : objectToString_default(value);\n}\nvar baseGetTag_default = baseGetTag;\n\n// ../../node_modules/lodash-es/isObjectLike.js\nfunction isObjectLike(value) {\n  return value != null && typeof value == \"object\";\n}\nvar isObjectLike_default = isObjectLike;\n\n// ../../node_modules/lodash-es/isSymbol.js\nvar symbolTag = \"[object Symbol]\";\nfunction isSymbol(value) {\n  return typeof value == \"symbol\" || isObjectLike_default(value) && baseGetTag_default(value) == symbolTag;\n}\nvar isSymbol_default = isSymbol;\n\n// ../../node_modules/lodash-es/_isKey.js\nvar reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/;\nvar reIsPlainProp = /^\\w*$/;\nfunction isKey(value, object) {\n  if (isArray_default(value)) {\n    return false;\n  }\n  var type = typeof value;\n  if (type == \"number\" || type == \"symbol\" || type == \"boolean\" || value == null || isSymbol_default(value)) {\n    return true;\n  }\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);\n}\nvar isKey_default = isKey;\n\n// ../../node_modules/lodash-es/isObject.js\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == \"object\" || type == \"function\");\n}\nvar isObject_default = isObject;\n\n// ../../node_modules/lodash-es/isFunction.js\nvar asyncTag = \"[object AsyncFunction]\";\nvar funcTag = \"[object Function]\";\nvar genTag = \"[object GeneratorFunction]\";\nvar proxyTag = \"[object Proxy]\";\nfunction isFunction(value) {\n  if (!isObject_default(value)) {\n    return false;\n  }\n  var tag = baseGetTag_default(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\nvar isFunction_default = isFunction;\n\n// ../../node_modules/lodash-es/_coreJsData.js\nvar coreJsData = root_default[\"__core-js_shared__\"];\nvar coreJsData_default = coreJsData;\n\n// ../../node_modules/lodash-es/_isMasked.js\nvar maskSrcKey = function () {\n  var uid = /[^.]+$/.exec(coreJsData_default && coreJsData_default.keys && coreJsData_default.keys.IE_PROTO || \"\");\n  return uid ? \"Symbol(src)_1.\" + uid : \"\";\n}();\nfunction isMasked(func) {\n  return !!maskSrcKey && maskSrcKey in func;\n}\nvar isMasked_default = isMasked;\n\n// ../../node_modules/lodash-es/_toSource.js\nvar funcProto = Function.prototype;\nvar funcToString = funcProto.toString;\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return func + \"\";\n    } catch (e) {}\n  }\n  return \"\";\n}\nvar toSource_default = toSource;\n\n// ../../node_modules/lodash-es/_baseIsNative.js\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\nvar funcProto2 = Function.prototype;\nvar objectProto3 = Object.prototype;\nvar funcToString2 = funcProto2.toString;\nvar hasOwnProperty2 = objectProto3.hasOwnProperty;\nvar reIsNative = RegExp(\"^\" + funcToString2.call(hasOwnProperty2).replace(reRegExpChar, \"\\\\$&\").replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, \"$1.*?\") + \"$\");\nfunction baseIsNative(value) {\n  if (!isObject_default(value) || isMasked_default(value)) {\n    return false;\n  }\n  var pattern = isFunction_default(value) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource_default(value));\n}\nvar baseIsNative_default = baseIsNative;\n\n// ../../node_modules/lodash-es/_getValue.js\nfunction getValue(object, key) {\n  return object == null ? void 0 : object[key];\n}\nvar getValue_default = getValue;\n\n// ../../node_modules/lodash-es/_getNative.js\nfunction getNative(object, key) {\n  var value = getValue_default(object, key);\n  return baseIsNative_default(value) ? value : void 0;\n}\nvar getNative_default = getNative;\n\n// ../../node_modules/lodash-es/_nativeCreate.js\nvar nativeCreate = getNative_default(Object, \"create\");\nvar nativeCreate_default = nativeCreate;\n\n// ../../node_modules/lodash-es/_hashClear.js\nfunction hashClear() {\n  this.__data__ = nativeCreate_default ? nativeCreate_default(null) : {};\n  this.size = 0;\n}\nvar hashClear_default = hashClear;\n\n// ../../node_modules/lodash-es/_hashDelete.js\nfunction hashDelete(key) {\n  var result = this.has(key) && delete this.__data__[key];\n  this.size -= result ? 1 : 0;\n  return result;\n}\nvar hashDelete_default = hashDelete;\n\n// ../../node_modules/lodash-es/_hashGet.js\nvar HASH_UNDEFINED = \"__lodash_hash_undefined__\";\nvar objectProto4 = Object.prototype;\nvar hasOwnProperty3 = objectProto4.hasOwnProperty;\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate_default) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? void 0 : result;\n  }\n  return hasOwnProperty3.call(data, key) ? data[key] : void 0;\n}\nvar hashGet_default = hashGet;\n\n// ../../node_modules/lodash-es/_hashHas.js\nvar objectProto5 = Object.prototype;\nvar hasOwnProperty4 = objectProto5.hasOwnProperty;\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate_default ? data[key] !== void 0 : hasOwnProperty4.call(data, key);\n}\nvar hashHas_default = hashHas;\n\n// ../../node_modules/lodash-es/_hashSet.js\nvar HASH_UNDEFINED2 = \"__lodash_hash_undefined__\";\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  this.size += this.has(key) ? 0 : 1;\n  data[key] = nativeCreate_default && value === void 0 ? HASH_UNDEFINED2 : value;\n  return this;\n}\nvar hashSet_default = hashSet;\n\n// ../../node_modules/lodash-es/_Hash.js\nfunction Hash(entries) {\n  var index = -1,\n    length = entries == null ? 0 : entries.length;\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\nHash.prototype.clear = hashClear_default;\nHash.prototype[\"delete\"] = hashDelete_default;\nHash.prototype.get = hashGet_default;\nHash.prototype.has = hashHas_default;\nHash.prototype.set = hashSet_default;\nvar Hash_default = Hash;\n\n// ../../node_modules/lodash-es/_listCacheClear.js\nfunction listCacheClear() {\n  this.__data__ = [];\n  this.size = 0;\n}\nvar listCacheClear_default = listCacheClear;\n\n// ../../node_modules/lodash-es/eq.js\nfunction eq(value, other) {\n  return value === other || value !== value && other !== other;\n}\nvar eq_default = eq;\n\n// ../../node_modules/lodash-es/_assocIndexOf.js\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq_default(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\nvar assocIndexOf_default = assocIndexOf;\n\n// ../../node_modules/lodash-es/_listCacheDelete.js\nvar arrayProto = Array.prototype;\nvar splice = arrayProto.splice;\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n    index = assocIndexOf_default(data, key);\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  --this.size;\n  return true;\n}\nvar listCacheDelete_default = listCacheDelete;\n\n// ../../node_modules/lodash-es/_listCacheGet.js\nfunction listCacheGet(key) {\n  var data = this.__data__,\n    index = assocIndexOf_default(data, key);\n  return index < 0 ? void 0 : data[index][1];\n}\nvar listCacheGet_default = listCacheGet;\n\n// ../../node_modules/lodash-es/_listCacheHas.js\nfunction listCacheHas(key) {\n  return assocIndexOf_default(this.__data__, key) > -1;\n}\nvar listCacheHas_default = listCacheHas;\n\n// ../../node_modules/lodash-es/_listCacheSet.js\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n    index = assocIndexOf_default(data, key);\n  if (index < 0) {\n    ++this.size;\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\nvar listCacheSet_default = listCacheSet;\n\n// ../../node_modules/lodash-es/_ListCache.js\nfunction ListCache(entries) {\n  var index = -1,\n    length = entries == null ? 0 : entries.length;\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\nListCache.prototype.clear = listCacheClear_default;\nListCache.prototype[\"delete\"] = listCacheDelete_default;\nListCache.prototype.get = listCacheGet_default;\nListCache.prototype.has = listCacheHas_default;\nListCache.prototype.set = listCacheSet_default;\nvar ListCache_default = ListCache;\n\n// ../../node_modules/lodash-es/_Map.js\nvar Map2 = getNative_default(root_default, \"Map\");\nvar Map_default = Map2;\n\n// ../../node_modules/lodash-es/_mapCacheClear.js\nfunction mapCacheClear() {\n  this.size = 0;\n  this.__data__ = {\n    \"hash\": new Hash_default(),\n    \"map\": new (Map_default || ListCache_default)(),\n    \"string\": new Hash_default()\n  };\n}\nvar mapCacheClear_default = mapCacheClear;\n\n// ../../node_modules/lodash-es/_isKeyable.js\nfunction isKeyable(value) {\n  var type = typeof value;\n  return type == \"string\" || type == \"number\" || type == \"symbol\" || type == \"boolean\" ? value !== \"__proto__\" : value === null;\n}\nvar isKeyable_default = isKeyable;\n\n// ../../node_modules/lodash-es/_getMapData.js\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable_default(key) ? data[typeof key == \"string\" ? \"string\" : \"hash\"] : data.map;\n}\nvar getMapData_default = getMapData;\n\n// ../../node_modules/lodash-es/_mapCacheDelete.js\nfunction mapCacheDelete(key) {\n  var result = getMapData_default(this, key)[\"delete\"](key);\n  this.size -= result ? 1 : 0;\n  return result;\n}\nvar mapCacheDelete_default = mapCacheDelete;\n\n// ../../node_modules/lodash-es/_mapCacheGet.js\nfunction mapCacheGet(key) {\n  return getMapData_default(this, key).get(key);\n}\nvar mapCacheGet_default = mapCacheGet;\n\n// ../../node_modules/lodash-es/_mapCacheHas.js\nfunction mapCacheHas(key) {\n  return getMapData_default(this, key).has(key);\n}\nvar mapCacheHas_default = mapCacheHas;\n\n// ../../node_modules/lodash-es/_mapCacheSet.js\nfunction mapCacheSet(key, value) {\n  var data = getMapData_default(this, key),\n    size = data.size;\n  data.set(key, value);\n  this.size += data.size == size ? 0 : 1;\n  return this;\n}\nvar mapCacheSet_default = mapCacheSet;\n\n// ../../node_modules/lodash-es/_MapCache.js\nfunction MapCache(entries) {\n  var index = -1,\n    length = entries == null ? 0 : entries.length;\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\nMapCache.prototype.clear = mapCacheClear_default;\nMapCache.prototype[\"delete\"] = mapCacheDelete_default;\nMapCache.prototype.get = mapCacheGet_default;\nMapCache.prototype.has = mapCacheHas_default;\nMapCache.prototype.set = mapCacheSet_default;\nvar MapCache_default = MapCache;\n\n// ../../node_modules/lodash-es/memoize.js\nvar FUNC_ERROR_TEXT = \"Expected a function\";\nfunction memoize(func, resolver) {\n  if (typeof func != \"function\" || resolver != null && typeof resolver != \"function\") {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var memoized = function memoized() {\n    var args = arguments,\n      key = resolver ? resolver.apply(this, args) : args[0],\n      cache = memoized.cache;\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    var result = func.apply(this, args);\n    memoized.cache = cache.set(key, result) || cache;\n    return result;\n  };\n  memoized.cache = new (memoize.Cache || MapCache_default)();\n  return memoized;\n}\nmemoize.Cache = MapCache_default;\nvar memoize_default = memoize;\n\n// ../../node_modules/lodash-es/_memoizeCapped.js\nvar MAX_MEMOIZE_SIZE = 500;\nfunction memoizeCapped(func) {\n  var result = memoize_default(func, function (key) {\n    if (cache.size === MAX_MEMOIZE_SIZE) {\n      cache.clear();\n    }\n    return key;\n  });\n  var cache = result.cache;\n  return result;\n}\nvar memoizeCapped_default = memoizeCapped;\n\n// ../../node_modules/lodash-es/_stringToPath.js\nvar rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\nvar reEscapeChar = /\\\\(\\\\)?/g;\nvar stringToPath = memoizeCapped_default(function (string) {\n  var result = [];\n  if (string.charCodeAt(0) === 46) {\n    result.push(\"\");\n  }\n  string.replace(rePropName, function (match, number, quote, subString) {\n    result.push(quote ? subString.replace(reEscapeChar, \"$1\") : number || match);\n  });\n  return result;\n});\nvar stringToPath_default = stringToPath;\n\n// ../../node_modules/lodash-es/_arrayMap.js\nfunction arrayMap(array, iteratee) {\n  var index = -1,\n    length = array == null ? 0 : array.length,\n    result = Array(length);\n  while (++index < length) {\n    result[index] = iteratee(array[index], index, array);\n  }\n  return result;\n}\nvar arrayMap_default = arrayMap;\n\n// ../../node_modules/lodash-es/_baseToString.js\nvar INFINITY = 1 / 0;\nvar symbolProto = Symbol_default ? Symbol_default.prototype : void 0;\nvar symbolToString = symbolProto ? symbolProto.toString : void 0;\nfunction baseToString(value) {\n  if (typeof value == \"string\") {\n    return value;\n  }\n  if (isArray_default(value)) {\n    return arrayMap_default(value, baseToString) + \"\";\n  }\n  if (isSymbol_default(value)) {\n    return symbolToString ? symbolToString.call(value) : \"\";\n  }\n  var result = value + \"\";\n  return result == \"0\" && 1 / value == -INFINITY ? \"-0\" : result;\n}\nvar baseToString_default = baseToString;\n\n// ../../node_modules/lodash-es/toString.js\nfunction toString(value) {\n  return value == null ? \"\" : baseToString_default(value);\n}\nvar toString_default = toString;\n\n// ../../node_modules/lodash-es/_castPath.js\nfunction castPath(value, object) {\n  if (isArray_default(value)) {\n    return value;\n  }\n  return isKey_default(value, object) ? [value] : stringToPath_default(toString_default(value));\n}\nvar castPath_default = castPath;\n\n// ../../node_modules/lodash-es/_toKey.js\nvar INFINITY2 = 1 / 0;\nfunction toKey(value) {\n  if (typeof value == \"string\" || isSymbol_default(value)) {\n    return value;\n  }\n  var result = value + \"\";\n  return result == \"0\" && 1 / value == -INFINITY2 ? \"-0\" : result;\n}\nvar toKey_default = toKey;\n\n// ../../node_modules/lodash-es/_baseGet.js\nfunction baseGet(object, path) {\n  path = castPath_default(path, object);\n  var index = 0,\n    length = path.length;\n  while (object != null && index < length) {\n    object = object[toKey_default(path[index++])];\n  }\n  return index && index == length ? object : void 0;\n}\nvar baseGet_default = baseGet;\n\n// ../../node_modules/lodash-es/get.js\nfunction get(object, path, defaultValue) {\n  var result = object == null ? void 0 : baseGet_default(object, path);\n  return result === void 0 ? defaultValue : result;\n}\nvar get_default = get;\n\n// ../../node_modules/lodash-es/_overArg.js\nfunction overArg(func, transform) {\n  return function (arg) {\n    return func(transform(arg));\n  };\n}\nvar overArg_default = overArg;\n\n// ../../node_modules/lodash-es/_getPrototype.js\nvar getPrototype = overArg_default(Object.getPrototypeOf, Object);\nvar getPrototype_default = getPrototype;\n\n// ../../node_modules/lodash-es/isPlainObject.js\nvar objectTag = \"[object Object]\";\nvar funcProto3 = Function.prototype;\nvar objectProto6 = Object.prototype;\nvar funcToString3 = funcProto3.toString;\nvar hasOwnProperty5 = objectProto6.hasOwnProperty;\nvar objectCtorString = funcToString3.call(Object);\nfunction isPlainObject(value) {\n  if (!isObjectLike_default(value) || baseGetTag_default(value) != objectTag) {\n    return false;\n  }\n  var proto = getPrototype_default(value);\n  if (proto === null) {\n    return true;\n  }\n  var Ctor = hasOwnProperty5.call(proto, \"constructor\") && proto.constructor;\n  return typeof Ctor == \"function\" && Ctor instanceof Ctor && funcToString3.call(Ctor) == objectCtorString;\n}\nvar isPlainObject_default = isPlainObject;\n\n// ../../node_modules/lodash-es/last.js\nfunction last(array) {\n  var length = array == null ? 0 : array.length;\n  return length ? array[length - 1] : void 0;\n}\nvar last_default = last;\n\n// src/pointer.ts\nvar pointerMetaWeakMap = new WeakMap();\nvar cachedSubPathPointersWeakMap = new WeakMap();\nvar pointerMetaSymbol = Symbol(\"pointerMeta\");\nvar proxyHandler = {\n  get: function get(pointerKey, prop) {\n    if (prop === pointerMetaSymbol) return pointerMetaWeakMap.get(pointerKey);\n    var subPathPointers = cachedSubPathPointersWeakMap.get(pointerKey);\n    if (!subPathPointers) {\n      subPathPointers = new Map();\n      cachedSubPathPointersWeakMap.set(pointerKey, subPathPointers);\n    }\n    var existing = subPathPointers.get(prop);\n    if (existing !== void 0) return existing;\n    var meta = pointerMetaWeakMap.get(pointerKey);\n    var subPointer = pointer({\n      root: meta.root,\n      path: [].concat(_toConsumableArray(meta.path), [prop])\n    });\n    subPathPointers.set(prop, subPointer);\n    return subPointer;\n  }\n};\nvar getPointerMeta = function getPointerMeta(p) {\n  var meta = p[pointerMetaSymbol];\n  return meta;\n};\nvar _getPointerParts = function _getPointerParts(p) {\n  var _getPointerMeta = getPointerMeta(p),\n    root2 = _getPointerMeta.root,\n    path = _getPointerMeta.path;\n  return {\n    root: root2,\n    path: path\n  };\n};\nfunction pointer(args) {\n  var _a;\n  var meta = {\n    root: args.root,\n    path: (_a = args.path) != null ? _a : []\n  };\n  var pointerKey = {};\n  pointerMetaWeakMap.set(pointerKey, meta);\n  return new Proxy(pointerKey, proxyHandler);\n}\nvar pointer_default = pointer;\nvar _isPointer = function _isPointer(p) {\n  return p && !!getPointerMeta(p);\n};\n\n// src/utils/updateDeep.ts\nfunction updateDeep(state2, path, reducer) {\n  if (path.length === 0) return reducer(state2);\n  return hoop(state2, path, reducer);\n}\nvar hoop = function hoop(s, path, reducer) {\n  if (path.length === 0) {\n    return reducer(s);\n  }\n  if (Array.isArray(s)) {\n    var _path2 = _toArray(path),\n      index = _path2[0],\n      restOfPath = _path2.slice(1);\n    index = parseInt(String(index), 10);\n    if (isNaN(index)) index = 0;\n    var oldVal = s[index];\n    var newVal = hoop(oldVal, restOfPath, reducer);\n    if (oldVal === newVal) return s;\n    var newS = _toConsumableArray(s);\n    newS.splice(index, 1, newVal);\n    return newS;\n  } else if (typeof s === \"object\" && s !== null) {\n    var _path3 = _toArray(path),\n      key = _path3[0],\n      _restOfPath = _path3.slice(1);\n    var _oldVal = s[key];\n    var _newVal = hoop(_oldVal, _restOfPath, reducer);\n    if (_oldVal === _newVal) return s;\n    var _newS = __spreadProps(__spreadValues({}, s), _defineProperty({}, key, _newVal));\n    return _newS;\n  } else {\n    var _path4 = _toArray(path),\n      _key = _path4[0],\n      _restOfPath2 = _path4.slice(1);\n    return _defineProperty({}, _key, hoop(void 0, _restOfPath2, reducer));\n  }\n};\n\n// src/utils/Stack.ts\nvar Stack = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function Stack() {\n    _classCallCheck(this, Stack);\n    this._head = void 0;\n  }\n  _createClass(Stack, [{\n    key: \"peek\",\n    value: function peek() {\n      return this._head && this._head.data;\n    }\n  }, {\n    key: \"pop\",\n    value: function pop() {\n      var head = this._head;\n      if (!head) {\n        return void 0;\n      }\n      this._head = head.next;\n      return head.data;\n    }\n  }, {\n    key: \"push\",\n    value: function push(data) {\n      var node = {\n        next: this._head,\n        data: data\n      };\n      this._head = node;\n    }\n  }]);\n  return Stack;\n}();\n\n// src/prism/Interface.ts\nfunction _isPrism(d) {\n  return !!(d && d.isPrism && d.isPrism === true);\n}\n\n// src/prism/discoveryMechanism.ts\nfunction createMechanism() {\n  var noop = function noop() {};\n  var stack = new Stack();\n  var noopCollector = noop;\n  var pushCollector2 = function pushCollector2(collector) {\n    stack.push(collector);\n  };\n  var popCollector2 = function popCollector2(collector) {\n    var existing = stack.peek();\n    if (existing !== collector) {\n      throw new Error(\"Popped collector is not on top of the stack\");\n    }\n    stack.pop();\n  };\n  var startIgnoringDependencies2 = function startIgnoringDependencies2() {\n    stack.push(noopCollector);\n  };\n  var stopIgnoringDependencies2 = function stopIgnoringDependencies2() {\n    if (stack.peek() !== noopCollector) {\n      if (process.env.NODE_ENV === \"development\") {\n        console.warn(\"This should never happen\");\n      }\n    } else {\n      stack.pop();\n    }\n  };\n  var reportResolutionStart2 = function reportResolutionStart2(d) {\n    var possibleCollector = stack.peek();\n    if (possibleCollector) {\n      possibleCollector(d);\n    }\n    stack.push(noopCollector);\n  };\n  var reportResolutionEnd2 = function reportResolutionEnd2(_d) {\n    stack.pop();\n  };\n  return {\n    type: \"Dataverse_discoveryMechanism\",\n    startIgnoringDependencies: startIgnoringDependencies2,\n    stopIgnoringDependencies: stopIgnoringDependencies2,\n    reportResolutionStart: reportResolutionStart2,\n    reportResolutionEnd: reportResolutionEnd2,\n    pushCollector: pushCollector2,\n    popCollector: popCollector2\n  };\n}\nfunction getSharedMechanism() {\n  var varName = \"__dataverse_discoveryMechanism_sharedStack\";\n  var root2 = typeof window !== \"undefined\" ? window : typeof global !== \"undefined\" ? global : {};\n  if (root2) {\n    var existingMechanism = root2[varName];\n    if (existingMechanism && typeof existingMechanism === \"object\" && existingMechanism.type === \"Dataverse_discoveryMechanism\") {\n      return existingMechanism;\n    } else {\n      var mechanism = createMechanism();\n      root2[varName] = mechanism;\n      return mechanism;\n    }\n  } else {\n    return createMechanism();\n  }\n}\nvar _getSharedMechanism = getSharedMechanism(),\n  startIgnoringDependencies = _getSharedMechanism.startIgnoringDependencies,\n  stopIgnoringDependencies = _getSharedMechanism.stopIgnoringDependencies,\n  reportResolutionEnd = _getSharedMechanism.reportResolutionEnd,\n  reportResolutionStart = _getSharedMechanism.reportResolutionStart,\n  pushCollector = _getSharedMechanism.pushCollector,\n  popCollector = _getSharedMechanism.popCollector;\n\n// src/prism/prism.ts\nvar voidFn = function voidFn() {};\nvar HotHandle = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function HotHandle(_fn, _prismInstance) {\n    var _this = this;\n    _classCallCheck(this, HotHandle);\n    this._fn = _fn;\n    this._prismInstance = _prismInstance;\n    this._didMarkDependentsAsStale = false;\n    this._isFresh = false;\n    this._cacheOfDendencyValues = new Map();\n    this._dependents = new Set();\n    this._dependencies = new Set();\n    this._possiblyStaleDeps = new Set();\n    this._scope = new HotScope(this);\n    this._lastValue = void 0;\n    this._forciblySetToStale = false;\n    this._reactToDependencyGoingStale = function (which) {\n      _this._possiblyStaleDeps.add(which);\n      _this._markAsStale();\n    };\n    var _iterator2 = _createForOfIteratorHelper(this._dependencies),\n      _step2;\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var d = _step2.value;\n        d._addDependent(this._reactToDependencyGoingStale);\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n    startIgnoringDependencies();\n    this.getValue();\n    stopIgnoringDependencies();\n  }\n  _createClass(HotHandle, [{\n    key: \"hasDependents\",\n    get: function get() {\n      return this._dependents.size > 0;\n    }\n  }, {\n    key: \"removeDependent\",\n    value: function removeDependent(d) {\n      this._dependents.delete(d);\n    }\n  }, {\n    key: \"addDependent\",\n    value: function addDependent(d) {\n      this._dependents.add(d);\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      var _iterator3 = _createForOfIteratorHelper(this._dependencies),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var d = _step3.value;\n          d._removeDependent(this._reactToDependencyGoingStale);\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n      cleanupScopeStack(this._scope);\n    }\n  }, {\n    key: \"getValue\",\n    value: function getValue() {\n      if (!this._isFresh) {\n        var newValue = this._recalculate();\n        this._lastValue = newValue;\n        this._isFresh = true;\n        this._didMarkDependentsAsStale = false;\n        this._forciblySetToStale = false;\n      }\n      return this._lastValue;\n    }\n  }, {\n    key: \"_recalculate\",\n    value: function _recalculate() {\n      var _this2 = this;\n      var value;\n      if (!this._forciblySetToStale) {\n        if (this._possiblyStaleDeps.size > 0) {\n          var anActuallyStaleDepWasFound = false;\n          startIgnoringDependencies();\n          var _iterator4 = _createForOfIteratorHelper(this._possiblyStaleDeps),\n            _step4;\n          try {\n            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n              var dep = _step4.value;\n              if (this._cacheOfDendencyValues.get(dep) !== dep.getValue()) {\n                anActuallyStaleDepWasFound = true;\n                break;\n              }\n            }\n          } catch (err) {\n            _iterator4.e(err);\n          } finally {\n            _iterator4.f();\n          }\n          stopIgnoringDependencies();\n          this._possiblyStaleDeps.clear();\n          if (!anActuallyStaleDepWasFound) {\n            return this._lastValue;\n          }\n        }\n      }\n      var newDeps = new Set();\n      this._cacheOfDendencyValues.clear();\n      var collector = function collector(observedDep) {\n        newDeps.add(observedDep);\n        _this2._addDependency(observedDep);\n      };\n      pushCollector(collector);\n      hookScopeStack.push(this._scope);\n      try {\n        value = this._fn();\n      } catch (error) {\n        console.error(error);\n      } finally {\n        var topOfTheStack = hookScopeStack.pop();\n        if (topOfTheStack !== this._scope) {\n          console.warn(\"The Prism hook stack has slipped. This is a bug.\");\n        }\n      }\n      popCollector(collector);\n      var _iterator5 = _createForOfIteratorHelper(this._dependencies),\n        _step5;\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var _dep = _step5.value;\n          if (!newDeps.has(_dep)) {\n            this._removeDependency(_dep);\n          }\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n      this._dependencies = newDeps;\n      startIgnoringDependencies();\n      var _iterator6 = _createForOfIteratorHelper(newDeps),\n        _step6;\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var _dep2 = _step6.value;\n          this._cacheOfDendencyValues.set(_dep2, _dep2.getValue());\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n      stopIgnoringDependencies();\n      return value;\n    }\n  }, {\n    key: \"forceStale\",\n    value: function forceStale() {\n      this._forciblySetToStale = true;\n      this._markAsStale();\n    }\n  }, {\n    key: \"_markAsStale\",\n    value: function _markAsStale() {\n      if (this._didMarkDependentsAsStale) return;\n      this._didMarkDependentsAsStale = true;\n      this._isFresh = false;\n      var _iterator7 = _createForOfIteratorHelper(this._dependents),\n        _step7;\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var dependent = _step7.value;\n          dependent(this._prismInstance);\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n    }\n  }, {\n    key: \"_addDependency\",\n    value: function _addDependency(d) {\n      if (this._dependencies.has(d)) return;\n      this._dependencies.add(d);\n      d._addDependent(this._reactToDependencyGoingStale);\n    }\n  }, {\n    key: \"_removeDependency\",\n    value: function _removeDependency(d) {\n      if (!this._dependencies.has(d)) return;\n      this._dependencies.delete(d);\n      d._removeDependent(this._reactToDependencyGoingStale);\n    }\n  }]);\n  return HotHandle;\n}();\nvar emptyObject = {};\nvar PrismInstance = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function PrismInstance(_fn) {\n    _classCallCheck(this, PrismInstance);\n    this._fn = _fn;\n    this.isPrism = true;\n    this._state = {\n      hot: false,\n      handle: void 0\n    };\n  }\n  _createClass(PrismInstance, [{\n    key: \"isHot\",\n    get: function get() {\n      return this._state.hot;\n    }\n  }, {\n    key: \"onChange\",\n    value: function onChange(ticker, listener) {\n      var _this3 = this;\n      var immediate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var dependent = function dependent() {\n        ticker.onThisOrNextTick(refresh);\n      };\n      var lastValue = emptyObject;\n      var refresh = function refresh() {\n        var newValue = _this3.getValue();\n        if (newValue === lastValue) return;\n        lastValue = newValue;\n        listener(newValue);\n      };\n      this._addDependent(dependent);\n      if (immediate) {\n        lastValue = this.getValue();\n        listener(lastValue);\n      }\n      var unsubscribe = function unsubscribe() {\n        _this3._removeDependent(dependent);\n        ticker.offThisOrNextTick(refresh);\n        ticker.offNextTick(refresh);\n      };\n      return unsubscribe;\n    }\n  }, {\n    key: \"onStale\",\n    value: function onStale(callback) {\n      var _this4 = this;\n      var untap = function untap() {\n        _this4._removeDependent(fn);\n      };\n      var fn = function fn() {\n        return callback();\n      };\n      this._addDependent(fn);\n      return untap;\n    }\n  }, {\n    key: \"keepHot\",\n    value: function keepHot() {\n      return this.onStale(function () {});\n    }\n  }, {\n    key: \"_addDependent\",\n    value: function _addDependent(d) {\n      if (!this._state.hot) {\n        this._goHot();\n      }\n      this._state.handle.addDependent(d);\n    }\n  }, {\n    key: \"_goHot\",\n    value: function _goHot() {\n      var hotHandle = new HotHandle(this._fn, this);\n      this._state = {\n        hot: true,\n        handle: hotHandle\n      };\n    }\n  }, {\n    key: \"_removeDependent\",\n    value: function _removeDependent(d) {\n      var state2 = this._state;\n      if (!state2.hot) {\n        return;\n      }\n      var handle = state2.handle;\n      handle.removeDependent(d);\n      if (!handle.hasDependents) {\n        this._state = {\n          hot: false,\n          handle: void 0\n        };\n        handle.destroy();\n      }\n    }\n  }, {\n    key: \"getValue\",\n    value: function getValue() {\n      reportResolutionStart(this);\n      var state2 = this._state;\n      var val2;\n      if (state2.hot) {\n        val2 = state2.handle.getValue();\n      } else {\n        val2 = calculateColdPrism(this._fn);\n      }\n      reportResolutionEnd(this);\n      return val2;\n    }\n  }]);\n  return PrismInstance;\n}();\nvar HotScope = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function HotScope(_hotHandle) {\n    _classCallCheck(this, HotScope);\n    this._hotHandle = _hotHandle;\n    this._refs = new Map();\n    this.isPrismScope = true;\n    this.subs = {};\n    this.effects = new Map();\n    this.memos = new Map();\n  }\n  _createClass(HotScope, [{\n    key: \"ref\",\n    value: function ref(key, initialValue) {\n      var ref2 = this._refs.get(key);\n      if (ref2 !== void 0) {\n        return ref2;\n      } else {\n        var ref3 = {\n          current: initialValue\n        };\n        this._refs.set(key, ref3);\n        return ref3;\n      }\n    }\n  }, {\n    key: \"effect\",\n    value: function effect(key, cb, deps) {\n      var effect2 = this.effects.get(key);\n      if (effect2 === void 0) {\n        effect2 = {\n          cleanup: voidFn,\n          deps: void 0\n        };\n        this.effects.set(key, effect2);\n      }\n      if (depsHaveChanged(effect2.deps, deps)) {\n        effect2.cleanup();\n        startIgnoringDependencies();\n        effect2.cleanup = safelyRun(cb, voidFn).value;\n        stopIgnoringDependencies();\n        effect2.deps = deps;\n      }\n    }\n  }, {\n    key: \"memo\",\n    value: function memo(key, fn, deps) {\n      var memo2 = this.memos.get(key);\n      if (memo2 === void 0) {\n        memo2 = {\n          cachedValue: null,\n          deps: void 0\n        };\n        this.memos.set(key, memo2);\n      }\n      if (depsHaveChanged(memo2.deps, deps)) {\n        startIgnoringDependencies();\n        memo2.cachedValue = safelyRun(fn, void 0).value;\n        stopIgnoringDependencies();\n        memo2.deps = deps;\n      }\n      return memo2.cachedValue;\n    }\n  }, {\n    key: \"state\",\n    value: function state(key, initialValue) {\n      var _this5 = this;\n      var _this$memo = this.memo(\"state/\" + key, function () {\n          var value2 = {\n            current: initialValue\n          };\n          var setValue2 = function setValue2(newValue) {\n            value2.current = newValue;\n            _this5._hotHandle.forceStale();\n          };\n          return {\n            value: value2,\n            setValue: setValue2\n          };\n        }, []),\n        value = _this$memo.value,\n        setValue = _this$memo.setValue;\n      return [value.current, setValue];\n    }\n  }, {\n    key: \"sub\",\n    value: function sub(key) {\n      if (!this.subs[key]) {\n        this.subs[key] = new HotScope(this._hotHandle);\n      }\n      return this.subs[key];\n    }\n  }, {\n    key: \"cleanupEffects\",\n    value: function cleanupEffects() {\n      var _iterator8 = _createForOfIteratorHelper(this.effects.values()),\n        _step8;\n      try {\n        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n          var effect2 = _step8.value;\n          safelyRun(effect2.cleanup, void 0);\n        }\n      } catch (err) {\n        _iterator8.e(err);\n      } finally {\n        _iterator8.f();\n      }\n      this.effects.clear();\n    }\n  }, {\n    key: \"source\",\n    value: function source(subscribe, getValue2) {\n      var _this6 = this;\n      var sourceKey = \"$$source/blah\";\n      this.effect(sourceKey, function () {\n        var unsub = subscribe(function () {\n          _this6._hotHandle.forceStale();\n        });\n        return unsub;\n      }, [subscribe]);\n      return getValue2();\n    }\n  }]);\n  return HotScope;\n}();\nfunction cleanupScopeStack(scope2) {\n  for (var _i = 0, _Object$values = Object.values(scope2.subs); _i < _Object$values.length; _i++) {\n    var sub2 = _Object$values[_i];\n    cleanupScopeStack(sub2);\n  }\n  scope2.cleanupEffects();\n}\nfunction safelyRun(fn, returnValueInCaseOfError) {\n  try {\n    return {\n      value: fn(),\n      ok: true\n    };\n  } catch (error) {\n    setTimeout(function PrismReportThrow() {\n      throw error;\n    });\n    return {\n      value: returnValueInCaseOfError,\n      ok: false\n    };\n  }\n}\nvar hookScopeStack = new Stack();\nfunction ref(key, initialValue) {\n  var scope2 = hookScopeStack.peek();\n  if (!scope2) {\n    throw new Error(\"prism.ref() is called outside of a prism() call.\");\n  }\n  return scope2.ref(key, initialValue);\n}\nfunction effect(key, cb, deps) {\n  var scope2 = hookScopeStack.peek();\n  if (!scope2) {\n    throw new Error(\"prism.effect() is called outside of a prism() call.\");\n  }\n  return scope2.effect(key, cb, deps);\n}\nfunction depsHaveChanged(oldDeps, newDeps) {\n  if (oldDeps === void 0 || newDeps === void 0) {\n    return true;\n  }\n  var len = oldDeps.length;\n  if (len !== newDeps.length) return true;\n  for (var i = 0; i < len; i++) {\n    if (oldDeps[i] !== newDeps[i]) return true;\n  }\n  return false;\n}\nfunction memo(key, fn, deps) {\n  var scope2 = hookScopeStack.peek();\n  if (!scope2) {\n    throw new Error(\"prism.memo() is called outside of a prism() call.\");\n  }\n  return scope2.memo(key, fn, deps);\n}\nfunction state(key, initialValue) {\n  var scope2 = hookScopeStack.peek();\n  if (!scope2) {\n    throw new Error(\"prism.state() is called outside of a prism() call.\");\n  }\n  return scope2.state(key, initialValue);\n}\nfunction ensurePrism() {\n  var scope2 = hookScopeStack.peek();\n  if (!scope2) {\n    throw new Error(\"The parent function is called outside of a prism() call.\");\n  }\n}\nfunction scope(key, fn) {\n  var parentScope = hookScopeStack.peek();\n  if (!parentScope) {\n    throw new Error(\"prism.scope() is called outside of a prism() call.\");\n  }\n  var subScope = parentScope.sub(key);\n  hookScopeStack.push(subScope);\n  var ret = safelyRun(fn, void 0).value;\n  hookScopeStack.pop();\n  return ret;\n}\nfunction sub(key, fn, deps) {\n  return memo(key, function () {\n    return prism(fn);\n  }, deps).getValue();\n}\nfunction inPrism() {\n  return !!hookScopeStack.peek();\n}\nfunction source(subscribe, getValue2) {\n  var scope2 = hookScopeStack.peek();\n  if (!scope2) {\n    throw new Error(\"prism.source() is called outside of a prism() call.\");\n  }\n  return scope2.source(subscribe, getValue2);\n}\nvar prism = function prism(fn) {\n  return new PrismInstance(fn);\n};\nvar ColdScope = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function ColdScope() {\n    _classCallCheck(this, ColdScope);\n  }\n  _createClass(ColdScope, [{\n    key: \"effect\",\n    value: function effect(key, cb, deps) {\n      console.warn(\"prism.effect() does not run in cold prisms\");\n    }\n  }, {\n    key: \"memo\",\n    value: function memo(key, fn, deps) {\n      return fn();\n    }\n  }, {\n    key: \"state\",\n    value: function state(key, initialValue) {\n      return [initialValue, function () {}];\n    }\n  }, {\n    key: \"ref\",\n    value: function ref(key, initialValue) {\n      return {\n        current: initialValue\n      };\n    }\n  }, {\n    key: \"sub\",\n    value: function sub(key) {\n      return new ColdScope();\n    }\n  }, {\n    key: \"source\",\n    value: function source(subscribe, getValue2) {\n      return getValue2();\n    }\n  }]);\n  return ColdScope;\n}();\nfunction calculateColdPrism(fn) {\n  var scope2 = new ColdScope();\n  hookScopeStack.push(scope2);\n  var value;\n  try {\n    value = fn();\n  } catch (error) {\n    console.error(error);\n  } finally {\n    var topOfTheStack = hookScopeStack.pop();\n    if (topOfTheStack !== scope2) {\n      console.warn(\"The Prism hook stack has slipped. This is a bug.\");\n    }\n  }\n  return value;\n}\nprism.ref = ref;\nprism.effect = effect;\nprism.memo = memo;\nprism.ensurePrism = ensurePrism;\nprism.state = state;\nprism.scope = scope;\nprism.sub = sub;\nprism.inPrism = inPrism;\nprism.source = source;\nvar prism_default = prism;\n\n// src/Atom.ts\nvar ValueTypes;\n(function (ValueTypes2) {\n  ValueTypes2[ValueTypes2[\"Dict\"] = 0] = \"Dict\";\n  ValueTypes2[ValueTypes2[\"Array\"] = 1] = \"Array\";\n  ValueTypes2[ValueTypes2[\"Other\"] = 2] = \"Other\";\n})(ValueTypes || (ValueTypes = {}));\nvar getTypeOfValue = function getTypeOfValue(v) {\n  if (Array.isArray(v)) return 1;\n  if (isPlainObject_default(v)) return 0;\n  return 2;\n};\nvar getKeyOfValue = function getKeyOfValue(v, key) {\n  var vType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : getTypeOfValue(v);\n  if (vType === 0 && typeof key === \"string\") {\n    return v[key];\n  } else if (vType === 1 && isValidArrayIndex(key)) {\n    return v[key];\n  } else {\n    return void 0;\n  }\n};\nvar isValidArrayIndex = function isValidArrayIndex(key) {\n  var inNumber = typeof key === \"number\" ? key : parseInt(key, 10);\n  return !isNaN(inNumber) && inNumber >= 0 && inNumber < Infinity && (inNumber | 0) === inNumber;\n};\nvar Scope = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function Scope(_parent, _path) {\n    _classCallCheck(this, Scope);\n    this._parent = _parent;\n    this._path = _path;\n    this.children = new Map();\n    this.identityChangeListeners = new Set();\n  }\n  _createClass(Scope, [{\n    key: \"addIdentityChangeListener\",\n    value: function addIdentityChangeListener(cb) {\n      this.identityChangeListeners.add(cb);\n    }\n  }, {\n    key: \"removeIdentityChangeListener\",\n    value: function removeIdentityChangeListener(cb) {\n      this.identityChangeListeners.delete(cb);\n      this._checkForGC();\n    }\n  }, {\n    key: \"removeChild\",\n    value: function removeChild(key) {\n      this.children.delete(key);\n      this._checkForGC();\n    }\n  }, {\n    key: \"getChild\",\n    value: function getChild(key) {\n      return this.children.get(key);\n    }\n  }, {\n    key: \"getOrCreateChild\",\n    value: function getOrCreateChild(key) {\n      var child = this.children.get(key);\n      if (!child) {\n        child = child = new Scope(this, this._path.concat([key]));\n        this.children.set(key, child);\n      }\n      return child;\n    }\n  }, {\n    key: \"_checkForGC\",\n    value: function _checkForGC() {\n      if (this.identityChangeListeners.size > 0) return;\n      if (this.children.size > 0) return;\n      if (this._parent) {\n        this._parent.removeChild(last_default(this._path));\n      }\n    }\n  }]);\n  return Scope;\n}();\nvar _Atom = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function _Atom(initialState) {\n    var _this7 = this;\n    _classCallCheck(this, _Atom);\n    this.$$isPointerToPrismProvider = true;\n    this.pointer = pointer_default({\n      root: this,\n      path: []\n    });\n    this.prism = this.pointerToPrism(this.pointer);\n    this._onPointerValueChange = function (pointer2, cb) {\n      var _getPointerParts2 = _getPointerParts(pointer2),\n        path = _getPointerParts2.path;\n      var scope2 = _this7._getOrCreateScopeForPath(path);\n      scope2.identityChangeListeners.add(cb);\n      var unsubscribe = function unsubscribe() {\n        scope2.identityChangeListeners.delete(cb);\n      };\n      return unsubscribe;\n    };\n    this._currentState = initialState;\n    this._rootScope = new Scope(void 0, []);\n  }\n  _createClass(_Atom, [{\n    key: \"set\",\n    value: function set(newState) {\n      var oldState = this._currentState;\n      this._currentState = newState;\n      this._checkUpdates(this._rootScope, oldState, newState);\n    }\n  }, {\n    key: \"get\",\n    value: function get() {\n      return this._currentState;\n    }\n  }, {\n    key: \"getByPointer\",\n    value: function getByPointer(pointerOrFn) {\n      var pointer2 = _isPointer(pointerOrFn) ? pointerOrFn : pointerOrFn(this.pointer);\n      var path = _getPointerParts(pointer2).path;\n      return this._getIn(path);\n    }\n  }, {\n    key: \"_getIn\",\n    value: function _getIn(path) {\n      return path.length === 0 ? this.get() : get_default(this.get(), path);\n    }\n  }, {\n    key: \"reduce\",\n    value: function reduce(fn) {\n      this.set(fn(this.get()));\n    }\n  }, {\n    key: \"reduceByPointer\",\n    value: function reduceByPointer(pointerOrFn, reducer) {\n      var pointer2 = _isPointer(pointerOrFn) ? pointerOrFn : pointerOrFn(this.pointer);\n      var path = _getPointerParts(pointer2).path;\n      var newState = updateDeep(this.get(), path, reducer);\n      this.set(newState);\n    }\n  }, {\n    key: \"setByPointer\",\n    value: function setByPointer(pointerOrFn, val2) {\n      this.reduceByPointer(pointerOrFn, function () {\n        return val2;\n      });\n    }\n  }, {\n    key: \"_checkUpdates\",\n    value: function _checkUpdates(scope2, oldState, newState) {\n      if (oldState === newState) return;\n      var _iterator9 = _createForOfIteratorHelper(scope2.identityChangeListeners),\n        _step9;\n      try {\n        for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n          var cb = _step9.value;\n          cb(newState);\n        }\n      } catch (err) {\n        _iterator9.e(err);\n      } finally {\n        _iterator9.f();\n      }\n      if (scope2.children.size === 0) return;\n      var oldValueType = getTypeOfValue(oldState);\n      var newValueType = getTypeOfValue(newState);\n      if (oldValueType === 2 && oldValueType === newValueType) return;\n      var _iterator10 = _createForOfIteratorHelper(scope2.children),\n        _step10;\n      try {\n        for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n          var _step10$value = _slicedToArray(_step10.value, 2),\n            childKey = _step10$value[0],\n            childScope = _step10$value[1];\n          var oldChildVal = getKeyOfValue(oldState, childKey, oldValueType);\n          var newChildVal = getKeyOfValue(newState, childKey, newValueType);\n          this._checkUpdates(childScope, oldChildVal, newChildVal);\n        }\n      } catch (err) {\n        _iterator10.e(err);\n      } finally {\n        _iterator10.f();\n      }\n    }\n  }, {\n    key: \"_getOrCreateScopeForPath\",\n    value: function _getOrCreateScopeForPath(path) {\n      var curScope = this._rootScope;\n      var _iterator11 = _createForOfIteratorHelper(path),\n        _step11;\n      try {\n        for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n          var pathEl = _step11.value;\n          curScope = curScope.getOrCreateChild(pathEl);\n        }\n      } catch (err) {\n        _iterator11.e(err);\n      } finally {\n        _iterator11.f();\n      }\n      return curScope;\n    }\n  }, {\n    key: \"pointerToPrism\",\n    value: function pointerToPrism(pointer2) {\n      var _this8 = this;\n      var _getPointerParts3 = _getPointerParts(pointer2),\n        path = _getPointerParts3.path;\n      var subscribe = function subscribe(listener) {\n        return _this8._onPointerValueChange(pointer2, listener);\n      };\n      var getValue2 = function getValue2() {\n        return _this8._getIn(path);\n      };\n      return prism_default(function () {\n        return prism_default.source(subscribe, getValue2);\n      });\n    }\n  }]);\n  return _Atom;\n}();\n\n// src/pointerToPrism.ts\nvar identifyPrismWeakMap = new WeakMap();\nfunction isPointerToPrismProvider(val2) {\n  return typeof val2 === \"object\" && val2 !== null && val2[\"$$isPointerToPrismProvider\"] === true;\n}\nvar _pointerToPrism = function _pointerToPrism(pointer2) {\n  var meta = getPointerMeta(pointer2);\n  var prismInstance = identifyPrismWeakMap.get(meta);\n  if (!prismInstance) {\n    var root2 = meta.root;\n    if (!isPointerToPrismProvider(root2)) {\n      throw new Error(\"Cannot run pointerToPrism() on a pointer whose root is not an PointerToPrismProvider\");\n    }\n    prismInstance = root2.pointerToPrism(pointer2);\n    identifyPrismWeakMap.set(meta, prismInstance);\n  }\n  return prismInstance;\n};\n\n// src/val.ts\nvar _val = function _val(input) {\n  if (_isPointer(input)) {\n    return _pointerToPrism(input).getValue();\n  } else if (_isPrism(input)) {\n    return input.getValue();\n  } else {\n    return input;\n  }\n};\n\n// src/prism/iterateAndCountTicks.ts\nfunction _iterateAndCountTicks(pointerOrPrism) {\n  var d, ticksCountedSinceLastYield, untap, ticks;\n  return _regeneratorRuntime().wrap(function _iterateAndCountTicks$(_context) {\n    while (1) switch (_context.prev = _context.next) {\n      case 0:\n        if (!_isPointer(pointerOrPrism)) {\n          _context.next = 4;\n          break;\n        }\n        d = _pointerToPrism(pointerOrPrism);\n        _context.next = 9;\n        break;\n      case 4:\n        if (!_isPrism(pointerOrPrism)) {\n          _context.next = 8;\n          break;\n        }\n        d = pointerOrPrism;\n        _context.next = 9;\n        break;\n      case 8:\n        throw new Error(\"Only pointers and prisms are supported\");\n      case 9:\n        ticksCountedSinceLastYield = 0;\n        untap = d.onStale(function () {\n          ticksCountedSinceLastYield++;\n        });\n        _context.prev = 11;\n      case 12:\n        if (!true) {\n          _context.next = 19;\n          break;\n        }\n        ticks = ticksCountedSinceLastYield;\n        ticksCountedSinceLastYield = 0;\n        _context.next = 17;\n        return {\n          value: d.getValue(),\n          ticks: ticks\n        };\n      case 17:\n        _context.next = 12;\n        break;\n      case 19:\n        _context.prev = 19;\n        untap();\n        return _context.finish(19);\n      case 22:\n      case \"end\":\n        return _context.stop();\n    }\n  }, _marked, null, [[11,, 19, 22]]);\n}\n\n// src/Ticker.ts\nvar EMPTY_TICKS_BEFORE_GOING_DORMANT = 60 * 3;\nvar _Ticker = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function _Ticker(_conf) {\n    _classCallCheck(this, _Ticker);\n    this._conf = _conf;\n    this._ticking = false;\n    this._dormant = true;\n    this._numberOfDormantTicks = 0;\n    this.__ticks = 0;\n    this._scheduledForThisOrNextTick = new Set();\n    this._scheduledForNextTick = new Set();\n    this._timeAtCurrentTick = 0;\n  }\n  _createClass(_Ticker, [{\n    key: \"dormant\",\n    get: function get() {\n      return this._dormant;\n    }\n  }, {\n    key: \"onThisOrNextTick\",\n    value: function onThisOrNextTick(fn) {\n      this._scheduledForThisOrNextTick.add(fn);\n      if (this._dormant) {\n        this._goActive();\n      }\n    }\n  }, {\n    key: \"onNextTick\",\n    value: function onNextTick(fn) {\n      this._scheduledForNextTick.add(fn);\n      if (this._dormant) {\n        this._goActive();\n      }\n    }\n  }, {\n    key: \"offThisOrNextTick\",\n    value: function offThisOrNextTick(fn) {\n      this._scheduledForThisOrNextTick.delete(fn);\n    }\n  }, {\n    key: \"offNextTick\",\n    value: function offNextTick(fn) {\n      this._scheduledForNextTick.delete(fn);\n    }\n  }, {\n    key: \"time\",\n    get: function get() {\n      if (this._ticking) {\n        return this._timeAtCurrentTick;\n      } else return performance.now();\n    }\n  }, {\n    key: \"_goActive\",\n    value: function _goActive() {\n      var _a, _b;\n      if (!this._dormant) return;\n      this._dormant = false;\n      (_b = (_a = this._conf) == null ? void 0 : _a.onActive) == null ? void 0 : _b.call(_a);\n    }\n  }, {\n    key: \"_goDormant\",\n    value: function _goDormant() {\n      var _a, _b;\n      if (this._dormant) return;\n      this._dormant = true;\n      this._numberOfDormantTicks = 0;\n      (_b = (_a = this._conf) == null ? void 0 : _a.onDormant) == null ? void 0 : _b.call(_a);\n    }\n  }, {\n    key: \"tick\",\n    value: function tick() {\n      var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : performance.now();\n      if (process.env.NODE_ENV === \"development\") {\n        if (!(this instanceof _Ticker)) {\n          throw new Error('ticker.tick must be called while bound to the ticker. As in, \"ticker.tick(time)\" or \"requestAnimationFrame((t) => ticker.tick(t))\" for performance.');\n        }\n      }\n      this.__ticks++;\n      if (!this._dormant) {\n        if (this._scheduledForNextTick.size === 0 && this._scheduledForThisOrNextTick.size === 0) {\n          this._numberOfDormantTicks++;\n          if (this._numberOfDormantTicks >= EMPTY_TICKS_BEFORE_GOING_DORMANT) {\n            this._goDormant();\n            return;\n          }\n        }\n      }\n      this._ticking = true;\n      this._timeAtCurrentTick = t;\n      var _iterator12 = _createForOfIteratorHelper(this._scheduledForNextTick),\n        _step12;\n      try {\n        for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n          var v = _step12.value;\n          this._scheduledForThisOrNextTick.add(v);\n        }\n      } catch (err) {\n        _iterator12.e(err);\n      } finally {\n        _iterator12.f();\n      }\n      this._scheduledForNextTick.clear();\n      this._tick(0);\n      this._ticking = false;\n    }\n  }, {\n    key: \"_tick\",\n    value: function _tick(iterationNumber) {\n      var time = this.time;\n      if (iterationNumber > 10) {\n        console.warn(\"_tick() recursing for 10 times\");\n      }\n      if (iterationNumber > 100) {\n        throw new Error(\"Maximum recursion limit for _tick()\");\n      }\n      var oldSet = this._scheduledForThisOrNextTick;\n      this._scheduledForThisOrNextTick = new Set();\n      var _iterator13 = _createForOfIteratorHelper(oldSet),\n        _step13;\n      try {\n        for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n          var fn = _step13.value;\n          fn(time);\n        }\n      } catch (err) {\n        _iterator13.e(err);\n      } finally {\n        _iterator13.f();\n      }\n      if (this._scheduledForThisOrNextTick.size > 0) {\n        return this._tick(iterationNumber + 1);\n      }\n    }\n  }]);\n  return _Ticker;\n}();\n\n// src/prism/iterateOver.ts\nfunction _iterateOver(pointerOrPrism) {\n  var d, ticker, untap;\n  return _regeneratorRuntime().wrap(function _iterateOver$(_context2) {\n    while (1) switch (_context2.prev = _context2.next) {\n      case 0:\n        if (!_isPointer(pointerOrPrism)) {\n          _context2.next = 4;\n          break;\n        }\n        d = _pointerToPrism(pointerOrPrism);\n        _context2.next = 9;\n        break;\n      case 4:\n        if (!_isPrism(pointerOrPrism)) {\n          _context2.next = 8;\n          break;\n        }\n        d = pointerOrPrism;\n        _context2.next = 9;\n        break;\n      case 8:\n        throw new Error(\"Only pointers and prisms are supported\");\n      case 9:\n        ticker = new _Ticker();\n        untap = d.onChange(ticker, function (v) {});\n        _context2.prev = 11;\n      case 12:\n        if (!true) {\n          _context2.next = 18;\n          break;\n        }\n        ticker.tick();\n        _context2.next = 16;\n        return d.getValue();\n      case 16:\n        _context2.next = 12;\n        break;\n      case 18:\n        _context2.prev = 18;\n        untap();\n        return _context2.finish(18);\n      case 21:\n      case \"end\":\n        return _context2.stop();\n    }\n  }, _marked2, null, [[11,, 18, 21]]);\n}\n\n// src/PointerProxy.ts\nvar _PointerProxy = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function _PointerProxy(currentPointer) {\n    _classCallCheck(this, _PointerProxy);\n    this.$$isPointerToPrismProvider = true;\n    this._currentPointerBox = new _Atom(currentPointer);\n    this.pointer = pointer_default({\n      root: this,\n      path: []\n    });\n  }\n  _createClass(_PointerProxy, [{\n    key: \"setPointer\",\n    value: function setPointer(p) {\n      this._currentPointerBox.set(p);\n    }\n  }, {\n    key: \"pointerToPrism\",\n    value: function pointerToPrism(pointer2) {\n      var _this9 = this;\n      var _getPointerMeta2 = getPointerMeta(pointer2),\n        path = _getPointerMeta2.path;\n      return prism_default(function () {\n        var currentPointer = _this9._currentPointerBox.prism.getValue();\n        var subPointer = path.reduce(function (pointerSoFar, pathItem) {\n          return pointerSoFar[pathItem];\n        }, currentPointer);\n        return _val(subPointer);\n      });\n    }\n  }]);\n  return _PointerProxy;\n}();","map":{"version":3,"sources":["../src/index.ts","../../../node_modules/lodash-es/isArray.js","../../../node_modules/lodash-es/_freeGlobal.js","../../../node_modules/lodash-es/_root.js","../../../node_modules/lodash-es/_Symbol.js","../../../node_modules/lodash-es/_getRawTag.js","../../../node_modules/lodash-es/_objectToString.js","../../../node_modules/lodash-es/_baseGetTag.js","../../../node_modules/lodash-es/isObjectLike.js","../../../node_modules/lodash-es/isSymbol.js","../../../node_modules/lodash-es/_isKey.js","../../../node_modules/lodash-es/isObject.js","../../../node_modules/lodash-es/isFunction.js","../../../node_modules/lodash-es/_coreJsData.js","../../../node_modules/lodash-es/_isMasked.js","../../../node_modules/lodash-es/_toSource.js","../../../node_modules/lodash-es/_baseIsNative.js","../../../node_modules/lodash-es/_getValue.js","../../../node_modules/lodash-es/_getNative.js","../../../node_modules/lodash-es/_nativeCreate.js","../../../node_modules/lodash-es/_hashClear.js","../../../node_modules/lodash-es/_hashDelete.js","../../../node_modules/lodash-es/_hashGet.js","../../../node_modules/lodash-es/_hashHas.js","../../../node_modules/lodash-es/_hashSet.js","../../../node_modules/lodash-es/_Hash.js","../../../node_modules/lodash-es/_listCacheClear.js","../../../node_modules/lodash-es/eq.js","../../../node_modules/lodash-es/_assocIndexOf.js","../../../node_modules/lodash-es/_listCacheDelete.js","../../../node_modules/lodash-es/_listCacheGet.js","../../../node_modules/lodash-es/_listCacheHas.js","../../../node_modules/lodash-es/_listCacheSet.js","../../../node_modules/lodash-es/_ListCache.js","../../../node_modules/lodash-es/_Map.js","../../../node_modules/lodash-es/_mapCacheClear.js","../../../node_modules/lodash-es/_isKeyable.js","../../../node_modules/lodash-es/_getMapData.js","../../../node_modules/lodash-es/_mapCacheDelete.js","../../../node_modules/lodash-es/_mapCacheGet.js","../../../node_modules/lodash-es/_mapCacheHas.js","../../../node_modules/lodash-es/_mapCacheSet.js","../../../node_modules/lodash-es/_MapCache.js","../../../node_modules/lodash-es/memoize.js","../../../node_modules/lodash-es/_memoizeCapped.js","../../../node_modules/lodash-es/_stringToPath.js","../../../node_modules/lodash-es/_arrayMap.js","../../../node_modules/lodash-es/_baseToString.js","../../../node_modules/lodash-es/toString.js","../../../node_modules/lodash-es/_castPath.js","../../../node_modules/lodash-es/_toKey.js","../../../node_modules/lodash-es/_baseGet.js","../../../node_modules/lodash-es/get.js","../../../node_modules/lodash-es/_overArg.js","../../../node_modules/lodash-es/_getPrototype.js","../../../node_modules/lodash-es/isPlainObject.js","../../../node_modules/lodash-es/last.js","../src/pointer.ts","../src/utils/updateDeep.ts","../src/utils/Stack.ts","../src/prism/Interface.ts","../src/prism/discoveryMechanism.ts","../src/prism/prism.ts","../src/Atom.ts","../src/pointerToPrism.ts","../src/val.ts","../src/prism/iterateAndCountTicks.ts","../src/Ticker.ts","../src/prism/iterateOver.ts","../src/PointerProxy.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * The animation-optimized FRP library powering the internals of Theatre.js.\n *\n * @packageDocumentation\n */\n\nexport type {PointerToPrismProvider} from './pointerToPrism'\nexport {default as Atom} from './Atom'\nexport {val} from './val'\nexport {pointerToPrism} from './pointerToPrism'\nexport {isPrism} from './prism/Interface'\nexport type {Prism} from './prism/Interface'\nexport {default as iterateAndCountTicks} from './prism/iterateAndCountTicks'\nexport {default as iterateOver} from './prism/iterateOver'\nexport {default as prism} from './prism/prism'\nexport {default as pointer, getPointerParts, isPointer} from './pointer'\nexport type {Pointer, PointerType, PointerMeta} from './pointer'\nexport {default as Ticker} from './Ticker'\nexport {default as PointerProxy} from './PointerProxy'\n","/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\nexport default isArray;\n","/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\nexport default freeGlobal;\n","import freeGlobal from './_freeGlobal.js';\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\nexport default root;\n","import root from './_root.js';\n\n/** Built-in value references. */\nvar Symbol = root.Symbol;\n\nexport default Symbol;\n","import Symbol from './_Symbol.js';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\nexport default getRawTag;\n","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\nexport default objectToString;\n","import Symbol from './_Symbol.js';\nimport getRawTag from './_getRawTag.js';\nimport objectToString from './_objectToString.js';\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\nexport default baseGetTag;\n","/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\nexport default isObjectLike;\n","import baseGetTag from './_baseGetTag.js';\nimport isObjectLike from './isObjectLike.js';\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && baseGetTag(value) == symbolTag);\n}\n\nexport default isSymbol;\n","import isArray from './isArray.js';\nimport isSymbol from './isSymbol.js';\n\n/** Used to match property names within property paths. */\nvar reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n    reIsPlainProp = /^\\w*$/;\n\n/**\n * Checks if `value` is a property name and not a property path.\n *\n * @private\n * @param {*} value The value to check.\n * @param {Object} [object] The object to query keys on.\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n */\nfunction isKey(value, object) {\n  if (isArray(value)) {\n    return false;\n  }\n  var type = typeof value;\n  if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n      value == null || isSymbol(value)) {\n    return true;\n  }\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n    (object != null && value in Object(object));\n}\n\nexport default isKey;\n","/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\nexport default isObject;\n","import baseGetTag from './_baseGetTag.js';\nimport isObject from './isObject.js';\n\n/** `Object#toString` result references. */\nvar asyncTag = '[object AsyncFunction]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    proxyTag = '[object Proxy]';\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\nexport default isFunction;\n","import root from './_root.js';\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\nexport default coreJsData;\n","import coreJsData from './_coreJsData.js';\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\nexport default isMasked;\n","/** Used for built-in method references. */\nvar funcProto = Function.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to convert.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\nexport default toSource;\n","import isFunction from './isFunction.js';\nimport isMasked from './_isMasked.js';\nimport isObject from './isObject.js';\nimport toSource from './_toSource.js';\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used for built-in method references. */\nvar funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\nexport default baseIsNative;\n","/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\nexport default getValue;\n","import baseIsNative from './_baseIsNative.js';\nimport getValue from './_getValue.js';\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\nexport default getNative;\n","import getNative from './_getNative.js';\n\n/* Built-in method references that are verified to be native. */\nvar nativeCreate = getNative(Object, 'create');\n\nexport default nativeCreate;\n","import nativeCreate from './_nativeCreate.js';\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n  this.size = 0;\n}\n\nexport default hashClear;\n","/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  var result = this.has(key) && delete this.__data__[key];\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\nexport default hashDelete;\n","import nativeCreate from './_nativeCreate.js';\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\nexport default hashGet;\n","import nativeCreate from './_nativeCreate.js';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);\n}\n\nexport default hashHas;\n","import nativeCreate from './_nativeCreate.js';\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  this.size += this.has(key) ? 0 : 1;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\nexport default hashSet;\n","import hashClear from './_hashClear.js';\nimport hashDelete from './_hashDelete.js';\nimport hashGet from './_hashGet.js';\nimport hashHas from './_hashHas.js';\nimport hashSet from './_hashSet.js';\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\nexport default Hash;\n","/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n  this.size = 0;\n}\n\nexport default listCacheClear;\n","/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\nexport default eq;\n","import eq from './eq.js';\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\nexport default assocIndexOf;\n","import assocIndexOf from './_assocIndexOf.js';\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype;\n\n/** Built-in value references. */\nvar splice = arrayProto.splice;\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  --this.size;\n  return true;\n}\n\nexport default listCacheDelete;\n","import assocIndexOf from './_assocIndexOf.js';\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\nexport default listCacheGet;\n","import assocIndexOf from './_assocIndexOf.js';\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\nexport default listCacheHas;\n","import assocIndexOf from './_assocIndexOf.js';\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    ++this.size;\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\nexport default listCacheSet;\n","import listCacheClear from './_listCacheClear.js';\nimport listCacheDelete from './_listCacheDelete.js';\nimport listCacheGet from './_listCacheGet.js';\nimport listCacheHas from './_listCacheHas.js';\nimport listCacheSet from './_listCacheSet.js';\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\nexport default ListCache;\n","import getNative from './_getNative.js';\nimport root from './_root.js';\n\n/* Built-in method references that are verified to be native. */\nvar Map = getNative(root, 'Map');\n\nexport default Map;\n","import Hash from './_Hash.js';\nimport ListCache from './_ListCache.js';\nimport Map from './_Map.js';\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.size = 0;\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\nexport default mapCacheClear;\n","/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\nexport default isKeyable;\n","import isKeyable from './_isKeyable.js';\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\nexport default getMapData;\n","import getMapData from './_getMapData.js';\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  var result = getMapData(this, key)['delete'](key);\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\nexport default mapCacheDelete;\n","import getMapData from './_getMapData.js';\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\nexport default mapCacheGet;\n","import getMapData from './_getMapData.js';\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\nexport default mapCacheHas;\n","import getMapData from './_getMapData.js';\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  var data = getMapData(this, key),\n      size = data.size;\n\n  data.set(key, value);\n  this.size += data.size == size ? 0 : 1;\n  return this;\n}\n\nexport default mapCacheSet;\n","import mapCacheClear from './_mapCacheClear.js';\nimport mapCacheDelete from './_mapCacheDelete.js';\nimport mapCacheGet from './_mapCacheGet.js';\nimport mapCacheHas from './_mapCacheHas.js';\nimport mapCacheSet from './_mapCacheSet.js';\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\nexport default MapCache;\n","import MapCache from './_MapCache.js';\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `clear`, `delete`, `get`, `has`, and `set`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to have its output memoized.\n * @param {Function} [resolver] The function to resolve the cache key.\n * @returns {Function} Returns the new memoized function.\n * @example\n *\n * var object = { 'a': 1, 'b': 2 };\n * var other = { 'c': 3, 'd': 4 };\n *\n * var values = _.memoize(_.values);\n * values(object);\n * // => [1, 2]\n *\n * values(other);\n * // => [3, 4]\n *\n * object.a = 2;\n * values(object);\n * // => [1, 2]\n *\n * // Modify the result cache.\n * values.cache.set(object, ['a', 'b']);\n * values(object);\n * // => ['a', 'b']\n *\n * // Replace `_.memoize.Cache`.\n * _.memoize.Cache = WeakMap;\n */\nfunction memoize(func, resolver) {\n  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var memoized = function() {\n    var args = arguments,\n        key = resolver ? resolver.apply(this, args) : args[0],\n        cache = memoized.cache;\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    var result = func.apply(this, args);\n    memoized.cache = cache.set(key, result) || cache;\n    return result;\n  };\n  memoized.cache = new (memoize.Cache || MapCache);\n  return memoized;\n}\n\n// Expose `MapCache`.\nmemoize.Cache = MapCache;\n\nexport default memoize;\n","import memoize from './memoize.js';\n\n/** Used as the maximum memoize cache size. */\nvar MAX_MEMOIZE_SIZE = 500;\n\n/**\n * A specialized version of `_.memoize` which clears the memoized function's\n * cache when it exceeds `MAX_MEMOIZE_SIZE`.\n *\n * @private\n * @param {Function} func The function to have its output memoized.\n * @returns {Function} Returns the new memoized function.\n */\nfunction memoizeCapped(func) {\n  var result = memoize(func, function(key) {\n    if (cache.size === MAX_MEMOIZE_SIZE) {\n      cache.clear();\n    }\n    return key;\n  });\n\n  var cache = result.cache;\n  return result;\n}\n\nexport default memoizeCapped;\n","import memoizeCapped from './_memoizeCapped.js';\n\n/** Used to match property names within property paths. */\nvar rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n/** Used to match backslashes in property paths. */\nvar reEscapeChar = /\\\\(\\\\)?/g;\n\n/**\n * Converts `string` to a property path array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the property path array.\n */\nvar stringToPath = memoizeCapped(function(string) {\n  var result = [];\n  if (string.charCodeAt(0) === 46 /* . */) {\n    result.push('');\n  }\n  string.replace(rePropName, function(match, number, quote, subString) {\n    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));\n  });\n  return result;\n});\n\nexport default stringToPath;\n","/**\n * A specialized version of `_.map` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction arrayMap(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      result = Array(length);\n\n  while (++index < length) {\n    result[index] = iteratee(array[index], index, array);\n  }\n  return result;\n}\n\nexport default arrayMap;\n","import Symbol from './_Symbol.js';\nimport arrayMap from './_arrayMap.js';\nimport isArray from './isArray.js';\nimport isSymbol from './isSymbol.js';\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isArray(value)) {\n    // Recursively convert values (susceptible to call stack limits).\n    return arrayMap(value, baseToString) + '';\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\nexport default baseToString;\n","import baseToString from './_baseToString.js';\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\nexport default toString;\n","import isArray from './isArray.js';\nimport isKey from './_isKey.js';\nimport stringToPath from './_stringToPath.js';\nimport toString from './toString.js';\n\n/**\n * Casts `value` to a path array if it's not one.\n *\n * @private\n * @param {*} value The value to inspect.\n * @param {Object} [object] The object to query keys on.\n * @returns {Array} Returns the cast property path array.\n */\nfunction castPath(value, object) {\n  if (isArray(value)) {\n    return value;\n  }\n  return isKey(value, object) ? [value] : stringToPath(toString(value));\n}\n\nexport default castPath;\n","import isSymbol from './isSymbol.js';\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/**\n * Converts `value` to a string key if it's not a string or symbol.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {string|symbol} Returns the key.\n */\nfunction toKey(value) {\n  if (typeof value == 'string' || isSymbol(value)) {\n    return value;\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\nexport default toKey;\n","import castPath from './_castPath.js';\nimport toKey from './_toKey.js';\n\n/**\n * The base implementation of `_.get` without support for default values.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @returns {*} Returns the resolved value.\n */\nfunction baseGet(object, path) {\n  path = castPath(path, object);\n\n  var index = 0,\n      length = path.length;\n\n  while (object != null && index < length) {\n    object = object[toKey(path[index++])];\n  }\n  return (index && index == length) ? object : undefined;\n}\n\nexport default baseGet;\n","import baseGet from './_baseGet.js';\n\n/**\n * Gets the value at `path` of `object`. If the resolved value is\n * `undefined`, the `defaultValue` is returned in its place.\n *\n * @static\n * @memberOf _\n * @since 3.7.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n * @returns {*} Returns the resolved value.\n * @example\n *\n * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n *\n * _.get(object, 'a[0].b.c');\n * // => 3\n *\n * _.get(object, ['a', '0', 'b', 'c']);\n * // => 3\n *\n * _.get(object, 'a.b.c', 'default');\n * // => 'default'\n */\nfunction get(object, path, defaultValue) {\n  var result = object == null ? undefined : baseGet(object, path);\n  return result === undefined ? defaultValue : result;\n}\n\nexport default get;\n","/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\nexport default overArg;\n","import overArg from './_overArg.js';\n\n/** Built-in value references. */\nvar getPrototype = overArg(Object.getPrototypeOf, Object);\n\nexport default getPrototype;\n","import baseGetTag from './_baseGetTag.js';\nimport getPrototype from './_getPrototype.js';\nimport isObjectLike from './isObjectLike.js';\n\n/** `Object#toString` result references. */\nvar objectTag = '[object Object]';\n\n/** Used for built-in method references. */\nvar funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to infer the `Object` constructor. */\nvar objectCtorString = funcToString.call(Object);\n\n/**\n * Checks if `value` is a plain object, that is, an object created by the\n * `Object` constructor or one with a `[[Prototype]]` of `null`.\n *\n * @static\n * @memberOf _\n * @since 0.8.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n * }\n *\n * _.isPlainObject(new Foo);\n * // => false\n *\n * _.isPlainObject([1, 2, 3]);\n * // => false\n *\n * _.isPlainObject({ 'x': 0, 'y': 0 });\n * // => true\n *\n * _.isPlainObject(Object.create(null));\n * // => true\n */\nfunction isPlainObject(value) {\n  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {\n    return false;\n  }\n  var proto = getPrototype(value);\n  if (proto === null) {\n    return true;\n  }\n  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;\n  return typeof Ctor == 'function' && Ctor instanceof Ctor &&\n    funcToString.call(Ctor) == objectCtorString;\n}\n\nexport default isPlainObject;\n","/**\n * Gets the last element of `array`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The array to query.\n * @returns {*} Returns the last element of `array`.\n * @example\n *\n * _.last([1, 2, 3]);\n * // => 3\n */\nfunction last(array) {\n  var length = array == null ? 0 : array.length;\n  return length ? array[length - 1] : undefined;\n}\n\nexport default last;\n","import type {$IntentionalAny} from './types'\n\ntype PathToProp = Array<string | number>\n\nexport type PointerMeta = {\n  root: {}\n  path: (string | number)[]\n}\n\n/** We are using an empty object as a WeakMap key for storing pointer meta data */\ntype WeakPointerKey = {}\n\nexport type UnindexableTypesForPointer =\n  | number\n  | string\n  | boolean\n  | null\n  | void\n  | undefined\n  | Function // eslint-disable-line @typescript-eslint/ban-types\n\nexport type UnindexablePointer = {\n  [K in $IntentionalAny]: Pointer<undefined>\n}\n\nconst pointerMetaWeakMap = new WeakMap<WeakPointerKey, PointerMeta>()\nconst cachedSubPathPointersWeakMap = new WeakMap<\n  WeakPointerKey,\n  Map<string | number, Pointer<unknown>>\n>()\n\n/**\n * A wrapper type for the type a `Pointer` points to.\n */\nexport type PointerType<O> = {\n  /**\n   * Only accessible via the type system.\n   * This is a helper for getting the underlying pointer type\n   * via the type space.\n   */\n  $$__pointer_type: O\n}\n\n/**\n * The type of {@link Atom} pointers. See {@link pointer|pointer()} for an\n * explanation of pointers.\n *\n * @see Atom\n *\n * @remarks\n * The Pointer type is quite tricky because it doesn't play well with `any` and other inexact types.\n * Here is an example that one would expect to work, but currently doesn't:\n * ```ts\n * declare function expectAnyPointer(pointer: Pointer<any>): void\n *\n * expectAnyPointer(null as Pointer<{}>) // this shows as a type error because Pointer<{}> is not assignable to Pointer<any>, even though it should\n * ```\n *\n * The current solution is to just avoid using `any` with pointer-related code (or type-test it well).\n * But if you enjoy solving typescript puzzles, consider fixing this :)\n * Potentially, [TypeScript variance annotations in 4.7+](https://devblogs.microsoft.com/typescript/announcing-typescript-4-7-beta/#optional-variance-annotations-for-type-parameters)\n * might be able to help us.\n */\nexport type Pointer<O> = PointerType<O> &\n  // `Exclude<O, undefined>` will remove `undefined` from the first type\n  // `undefined extends O ? undefined : never` will give us `undefined` if `O` is `... | undefined`\n  PointerInner<Exclude<O, undefined>, undefined extends O ? undefined : never>\n\n// By separating the `O` (non-undefined) from the `undefined` or `never`, we\n// can properly use `O extends ...` to determine the kind of potential value\n// without actually discarding optionality information.\ntype PointerInner<O, Optional> = O extends UnindexableTypesForPointer\n  ? UnindexablePointer\n  : unknown extends O\n  ? UnindexablePointer\n  : O extends (infer T)[]\n  ? Pointer<T>[]\n  : O extends {}\n  ? {\n      [K in keyof O]-?: Pointer<O[K] | Optional>\n    }\n  : UnindexablePointer\n\nconst pointerMetaSymbol = Symbol('pointerMeta')\n\nconst proxyHandler = {\n  get(\n    pointerKey: WeakPointerKey,\n    prop: string | typeof pointerMetaSymbol,\n  ): $IntentionalAny {\n    if (prop === pointerMetaSymbol) return pointerMetaWeakMap.get(pointerKey)!\n\n    let subPathPointers = cachedSubPathPointersWeakMap.get(pointerKey)\n    if (!subPathPointers) {\n      subPathPointers = new Map()\n      cachedSubPathPointersWeakMap.set(pointerKey, subPathPointers)\n    }\n\n    const existing = subPathPointers.get(prop)\n    if (existing !== undefined) return existing\n\n    const meta = pointerMetaWeakMap.get(pointerKey)!\n\n    const subPointer = pointer({root: meta.root, path: [...meta.path, prop]})\n    subPathPointers.set(prop, subPointer)\n    return subPointer\n  },\n}\n\n/**\n * Returns the metadata associated with the pointer. Usually the root object and\n * the path.\n *\n * @param p - The pointer.\n */\nexport const getPointerMeta = <_>(p: PointerType<_>): PointerMeta => {\n  // @ts-ignore @todo\n  const meta: PointerMeta = p[\n    pointerMetaSymbol as unknown as $IntentionalAny\n  ] as $IntentionalAny\n  return meta\n}\n\n/**\n * Returns the root object and the path of the pointer.\n *\n * @example\n * ```ts\n * const {root, path} = getPointerParts(pointer)\n * ```\n *\n * @param p - The pointer.\n *\n * @returns An object with two properties: `root`-the root object or the pointer, and `path`-the path of the pointer. `path` is an array of the property-chain.\n */\nexport const getPointerParts = <_>(\n  p: Pointer<_>,\n): {root: {}; path: PathToProp} => {\n  const {root, path} = getPointerMeta(p)\n  return {root, path}\n}\n\n/**\n * Creates a pointer to a (nested) property of an {@link Atom}.\n *\n * @remarks\n * Pointers are used to make prisms of properties or nested properties of\n * {@link Atom|Atoms}.\n *\n * Pointers also allow easy construction of new pointers pointing to nested members\n * of the root object, by simply using property chaining. E.g. `somePointer.a.b` will\n * create a new pointer that has `'a'` and `'b'` added to the path of `somePointer`.\n *\n * @example\n * ```ts\n * // Here, sum is a prism that updates whenever the a or b prop of someAtom does.\n * const sum = prism(() => {\n *   return val(pointer({root: someAtom, path: ['a']})) + val(pointer({root: someAtom, path: ['b']}));\n * });\n *\n * // Note, atoms have a convenience Atom.pointer property that points to the root,\n * // which you would normally use in this situation.\n * const sum = prism(() => {\n *   return val(someAtom.pointer.a) + val(someAtom.pointer.b);\n * });\n * ```\n *\n * @param args - The pointer parameters.\n *\n * @typeParam O - The type of the value being pointed to.\n */\nfunction pointer<O>(args: {root: {}; path?: Array<string | number>}) {\n  const meta: PointerMeta = {\n    root: args.root as $IntentionalAny,\n    path: args.path ?? [],\n  }\n  const pointerKey: WeakPointerKey = {}\n  pointerMetaWeakMap.set(pointerKey, meta)\n  return new Proxy(pointerKey, proxyHandler) as Pointer<O>\n}\n\nexport default pointer\n\n/**\n * Returns whether `p` is a pointer.\n */\nexport const isPointer = (p: $IntentionalAny): p is Pointer<unknown> => {\n  return p && !!getPointerMeta(p)\n}\n","import type {$FixMe, $IntentionalAny} from '../types'\n\nexport default function updateDeep<S>(\n  state: S,\n  path: (string | number | undefined)[],\n  reducer: (...args: $IntentionalAny[]) => $IntentionalAny,\n): S {\n  if (path.length === 0) return reducer(state)\n  return hoop(state, path as $IntentionalAny, reducer)\n}\n\nconst hoop = (\n  s: $FixMe,\n  path: (string | number)[],\n  reducer: $FixMe,\n): $FixMe => {\n  if (path.length === 0) {\n    return reducer(s)\n  }\n  if (Array.isArray(s)) {\n    let [index, ...restOfPath] = path\n    index = parseInt(String(index), 10)\n    if (isNaN(index)) index = 0\n    const oldVal = s[index]\n    const newVal = hoop(oldVal, restOfPath, reducer)\n    if (oldVal === newVal) return s\n    const newS = [...s]\n    newS.splice(index, 1, newVal)\n    return newS\n  } else if (typeof s === 'object' && s !== null) {\n    const [key, ...restOfPath] = path\n    const oldVal = s[key]\n    const newVal = hoop(oldVal, restOfPath, reducer)\n    if (oldVal === newVal) return s\n    const newS = {...s, [key]: newVal}\n    return newS\n  } else {\n    const [key, ...restOfPath] = path\n\n    return {[key]: hoop(undefined, restOfPath, reducer)}\n  }\n}\n","interface Node<Data> {\n  next: undefined | Node<Data>\n  data: Data\n}\n\n/**\n * Just a simple LinkedList\n */\nexport default class Stack<Data> {\n  _head: undefined | Node<Data>\n\n  constructor() {\n    this._head = undefined\n  }\n\n  peek() {\n    return this._head && this._head.data\n  }\n\n  pop() {\n    const head = this._head\n    if (!head) {\n      return undefined\n    }\n    this._head = head.next\n    return head.data\n  }\n\n  push(data: Data) {\n    const node = {next: this._head, data}\n    this._head = node\n  }\n}\n","import type Ticker from '../Ticker'\nimport type {$IntentionalAny, VoidFn} from '../types'\n\ntype IDependent = (msgComingFrom: Prism<$IntentionalAny>) => void\n\n/**\n * Common interface for prisms.\n */\nexport interface Prism<V> {\n  /**\n   * Whether the object is a prism.\n   */\n  isPrism: true\n\n  /**\n   * Whether the prism is hot.\n   */\n  isHot: boolean\n\n  /**\n   * Calls `listener` with a fresh value every time the prism _has_ a new value, throttled by Ticker.\n   */\n  onChange(\n    ticker: Ticker,\n    listener: (v: V) => void,\n    immediate?: boolean,\n  ): VoidFn\n\n  onStale(cb: () => void): VoidFn\n\n  /**\n   * Keep the prism hot, even if there are no tappers (subscribers).\n   */\n  keepHot(): VoidFn\n\n  /**\n   * Add a prism as a dependent of this prism.\n   *\n   * @param d - The prism to be made a dependent of this prism.\n   *\n   * @see _removeDependent\n   *\n   * @internal\n   */\n  _addDependent(d: IDependent): void\n\n  /**\n   * Remove a prism as a dependent of this prism.\n   *\n   * @param d - The prism to be removed from as a dependent of this prism.\n   *\n   * @see _addDependent\n   * @internal\n   */\n  _removeDependent(d: IDependent): void\n\n  /**\n   * Gets the current value of the prism. If the value is stale, it causes the prism to freshen.\n   */\n  getValue(): V\n}\n\n/**\n * Returns whether `d` is a prism.\n */\nexport function isPrism(d: any): d is Prism<unknown> {\n  return !!(d && d.isPrism && d.isPrism === true)\n}\n","import type {$IntentionalAny} from '../types'\nimport Stack from '../utils/Stack'\nimport type {Prism} from './Interface'\n\nfunction createMechanism() {\n  const noop = () => {}\n\n  const stack = new Stack<Collector>()\n  const noopCollector: Collector = noop\n\n  type Collector = (d: Prism<$IntentionalAny>) => void\n\n  const pushCollector = (collector: Collector): void => {\n    stack.push(collector)\n  }\n\n  const popCollector = (collector: Collector): void => {\n    const existing = stack.peek()\n    if (existing !== collector) {\n      throw new Error(`Popped collector is not on top of the stack`)\n    }\n    stack.pop()\n  }\n\n  const startIgnoringDependencies = () => {\n    stack.push(noopCollector)\n  }\n\n  const stopIgnoringDependencies = () => {\n    if (stack.peek() !== noopCollector) {\n      if (process.env.NODE_ENV === 'development') {\n        console.warn('This should never happen')\n      }\n    } else {\n      stack.pop()\n    }\n  }\n\n  const reportResolutionStart = (d: Prism<$IntentionalAny>) => {\n    const possibleCollector = stack.peek()\n    if (possibleCollector) {\n      possibleCollector(d)\n    }\n\n    stack.push(noopCollector)\n  }\n\n  const reportResolutionEnd = (_d: Prism<$IntentionalAny>) => {\n    stack.pop()\n  }\n\n  return {\n    type: 'Dataverse_discoveryMechanism' as 'Dataverse_discoveryMechanism',\n    startIgnoringDependencies,\n    stopIgnoringDependencies,\n    reportResolutionStart,\n    reportResolutionEnd,\n    pushCollector,\n    popCollector,\n  }\n}\n\nfunction getSharedMechanism(): ReturnType<typeof createMechanism> {\n  const varName = '__dataverse_discoveryMechanism_sharedStack'\n  const root =\n    typeof window !== 'undefined'\n      ? window\n      : typeof global !== 'undefined'\n      ? global\n      : {}\n  if (root) {\n    const existingMechanism: ReturnType<typeof createMechanism> | undefined =\n      // @ts-ignore ignore\n      root[varName]\n    if (\n      existingMechanism &&\n      typeof existingMechanism === 'object' &&\n      existingMechanism.type === 'Dataverse_discoveryMechanism'\n    ) {\n      return existingMechanism\n    } else {\n      const mechanism = createMechanism()\n      // @ts-ignore ignore\n      root[varName] = mechanism\n      return mechanism\n    }\n  } else {\n    return createMechanism()\n  }\n}\n\nexport const {\n  startIgnoringDependencies,\n  stopIgnoringDependencies,\n  reportResolutionEnd,\n  reportResolutionStart,\n  pushCollector,\n  popCollector,\n} = getSharedMechanism()\n","import type Ticker from '../Ticker'\nimport type {$IntentionalAny, VoidFn} from '../types'\nimport Stack from '../utils/Stack'\nimport type {Prism} from './Interface'\nimport {isPrism} from './Interface'\nimport {\n  startIgnoringDependencies,\n  stopIgnoringDependencies,\n  pushCollector,\n  popCollector,\n  reportResolutionStart,\n  reportResolutionEnd,\n} from './discoveryMechanism'\n\ntype IDependent = (msgComingFrom: Prism<$IntentionalAny>) => void\n\nconst voidFn = () => {}\n\nclass HotHandle<V> {\n  private _didMarkDependentsAsStale: boolean = false\n  private _isFresh: boolean = false\n  protected _cacheOfDendencyValues: Map<Prism<unknown>, unknown> = new Map()\n\n  /**\n   * @internal\n   */\n  protected _dependents: Set<IDependent> = new Set()\n\n  /**\n   * @internal\n   */\n  protected _dependencies: Set<Prism<$IntentionalAny>> = new Set()\n\n  protected _possiblyStaleDeps = new Set<Prism<unknown>>()\n\n  private _scope: HotScope = new HotScope(\n    this as $IntentionalAny as HotHandle<unknown>,\n  )\n\n  /**\n   * @internal\n   */\n  protected _lastValue: undefined | V = undefined\n\n  /**\n   * If true, the prism is stale even though its dependencies aren't\n   * marked as such. This is used by `prism.source()` and `prism.state()`\n   * to mark the prism as stale.\n   */\n  private _forciblySetToStale: boolean = false\n\n  constructor(\n    private readonly _fn: () => V,\n    private readonly _prismInstance: PrismInstance<V>,\n  ) {\n    for (const d of this._dependencies) {\n      d._addDependent(this._reactToDependencyGoingStale)\n    }\n\n    startIgnoringDependencies()\n    this.getValue()\n    stopIgnoringDependencies()\n  }\n\n  get hasDependents(): boolean {\n    return this._dependents.size > 0\n  }\n  removeDependent(d: IDependent) {\n    this._dependents.delete(d)\n  }\n  addDependent(d: IDependent) {\n    this._dependents.add(d)\n  }\n\n  destroy() {\n    for (const d of this._dependencies) {\n      d._removeDependent(this._reactToDependencyGoingStale)\n    }\n    cleanupScopeStack(this._scope)\n  }\n\n  getValue(): V {\n    if (!this._isFresh) {\n      const newValue = this._recalculate()\n      this._lastValue = newValue\n      this._isFresh = true\n      this._didMarkDependentsAsStale = false\n      this._forciblySetToStale = false\n    }\n    return this._lastValue!\n  }\n\n  _recalculate() {\n    let value: V\n\n    if (!this._forciblySetToStale) {\n      if (this._possiblyStaleDeps.size > 0) {\n        let anActuallyStaleDepWasFound = false\n        startIgnoringDependencies()\n        for (const dep of this._possiblyStaleDeps) {\n          if (this._cacheOfDendencyValues.get(dep) !== dep.getValue()) {\n            anActuallyStaleDepWasFound = true\n            break\n          }\n        }\n        stopIgnoringDependencies()\n        this._possiblyStaleDeps.clear()\n        if (!anActuallyStaleDepWasFound) {\n          return this._lastValue!\n        }\n      }\n    }\n\n    const newDeps: Set<Prism<unknown>> = new Set()\n    this._cacheOfDendencyValues.clear()\n\n    const collector = (observedDep: Prism<unknown>): void => {\n      newDeps.add(observedDep)\n      this._addDependency(observedDep)\n    }\n\n    pushCollector(collector)\n\n    hookScopeStack.push(this._scope)\n    try {\n      value = this._fn()\n    } catch (error) {\n      console.error(error)\n    } finally {\n      const topOfTheStack = hookScopeStack.pop()\n      if (topOfTheStack !== this._scope) {\n        console.warn(\n          // @todo guide the user to report the bug in an issue\n          `The Prism hook stack has slipped. This is a bug.`,\n        )\n      }\n    }\n\n    popCollector(collector)\n\n    for (const dep of this._dependencies) {\n      if (!newDeps.has(dep)) {\n        this._removeDependency(dep)\n      }\n    }\n\n    this._dependencies = newDeps\n\n    startIgnoringDependencies()\n    for (const dep of newDeps) {\n      this._cacheOfDendencyValues.set(dep, dep.getValue())\n    }\n    stopIgnoringDependencies()\n\n    return value!\n  }\n\n  forceStale() {\n    this._forciblySetToStale = true\n    this._markAsStale()\n  }\n\n  protected _reactToDependencyGoingStale = (which: Prism<$IntentionalAny>) => {\n    this._possiblyStaleDeps.add(which)\n\n    this._markAsStale()\n  }\n\n  private _markAsStale() {\n    if (this._didMarkDependentsAsStale) return\n\n    this._didMarkDependentsAsStale = true\n    this._isFresh = false\n\n    for (const dependent of this._dependents) {\n      dependent(this._prismInstance)\n    }\n  }\n\n  /**\n   * @internal\n   */\n  protected _addDependency(d: Prism<$IntentionalAny>) {\n    if (this._dependencies.has(d)) return\n    this._dependencies.add(d)\n    d._addDependent(this._reactToDependencyGoingStale)\n  }\n\n  /**\n   * @internal\n   */\n  protected _removeDependency(d: Prism<$IntentionalAny>) {\n    if (!this._dependencies.has(d)) return\n    this._dependencies.delete(d)\n    d._removeDependent(this._reactToDependencyGoingStale)\n  }\n}\n\nconst emptyObject = {}\n\nclass PrismInstance<V> implements Prism<V> {\n  /**\n   * Whether the object is a prism.\n   */\n  readonly isPrism: true = true\n\n  private _state:\n    | {hot: false; handle: undefined}\n    | {hot: true; handle: HotHandle<V>} = {\n    hot: false,\n    handle: undefined,\n  }\n\n  constructor(private readonly _fn: () => V) {}\n\n  /**\n   * Whether the prism is hot.\n   */\n  get isHot(): boolean {\n    return this._state.hot\n  }\n\n  onChange(\n    ticker: Ticker,\n    listener: (v: V) => void,\n    immediate: boolean = false,\n  ): VoidFn {\n    // the prism will call this function every time it goes from fresh to stale\n    const dependent = () => {\n      // schedule the listener to be called on the next tick, unless\n      // we're already on a tick, in which case it'll be called on the current tick.\n      ticker.onThisOrNextTick(refresh)\n    }\n\n    // let's cache the last value so we don't call the listener if the value hasn't changed\n    let lastValue =\n      // use an empty object as the initial value so that the listener is called on the first tick.\n      // if we were to use, say, undefined, and this.getValue() also returned undefined, the listener\n      // would never be called.\n      emptyObject\n\n    // this function will be _scheduled_ to be called on the currently running, or next tick,\n    // after the prism has gone from fresh to stale.\n    const refresh = () => {\n      const newValue = this.getValue()\n      // if the value hasn't changed, don't call the listener\n      if (newValue === lastValue) return\n\n      // the value has changed - cache it\n      lastValue = newValue\n\n      // and let the listener know\n      listener(newValue)\n    }\n\n    // add the dependent to the prism's list of dependents (which will make it go hot)\n    this._addDependent(dependent)\n\n    // if the caller wants the listener to be called immediately, call it now\n    if (immediate) {\n      lastValue = this.getValue()\n      listener(lastValue as $IntentionalAny as V)\n    }\n\n    // the unsubscribe function\n    const unsubscribe = () => {\n      // remove the dependent from the prism's list of dependents (and if it was the last dependent, the prism will go cold)\n      this._removeDependent(dependent)\n      // in case we're scheduled for a tick, cancel that\n      ticker.offThisOrNextTick(refresh)\n      ticker.offNextTick(refresh)\n    }\n\n    return unsubscribe\n  }\n\n  /**\n   * Calls `callback` every time the prism's state goes from `fresh-\\>stale.` Returns an `unsubscribe()` function.\n   */\n  onStale(callback: () => void): VoidFn {\n    const untap = () => {\n      this._removeDependent(fn)\n    }\n    const fn = () => callback()\n    this._addDependent(fn)\n    return untap\n  }\n\n  /**\n   * Keep the prism hot, even if there are no tappers (subscribers).\n   */\n  keepHot() {\n    return this.onStale(() => {})\n  }\n\n  /**\n   * Add a prism as a dependent of this prism.\n   *\n   * @param d - The prism to be made a dependent of this prism.\n   *\n   * @see _removeDependent\n   */\n  _addDependent(d: IDependent) {\n    if (!this._state.hot) {\n      this._goHot()\n    }\n    this._state.handle!.addDependent(d)\n  }\n\n  private _goHot() {\n    const hotHandle = new HotHandle(this._fn, this)\n    this._state = {\n      hot: true,\n      handle: hotHandle,\n    }\n  }\n\n  /**\n   * Remove a prism as a dependent of this prism.\n   *\n   * @param d - The prism to be removed from as a dependent of this prism.\n   *\n   * @see _addDependent\n   */\n  _removeDependent(d: IDependent) {\n    const state = this._state\n    if (!state.hot) {\n      return\n    }\n    const handle = state.handle\n    handle.removeDependent(d)\n    if (!handle.hasDependents) {\n      this._state = {hot: false, handle: undefined}\n      handle.destroy()\n    }\n  }\n\n  /**\n   * Gets the current value of the prism. If the value is stale, it causes the prism to freshen.\n   */\n  getValue(): V {\n    /**\n     * TODO We should prevent (or warn about) a common mistake users make, which is reading the value of\n     * a prism in the body of a react component (e.g. `der.getValue()` (often via `val()`) instead of `useVal()`\n     * or `uesPrism()`).\n     *\n     * Although that's the most common example of this mistake, you can also find it outside of react components.\n     * Basically the user runs `der.getValue()` assuming the read is detected by a wrapping prism when it's not.\n     *\n     * Sometiems the prism isn't even hot when the user assumes it is.\n     *\n     * We can fix this type of mistake by:\n     * 1. Warning the user when they call `getValue()` on a cold prism.\n     * 2. Warning the user about calling `getValue()` on a hot-but-stale prism\n     *    if `getValue()` isn't called by a known mechanism like a `PrismEmitter`.\n     *\n     * Design constraints:\n     * - This fix should not have a perf-penalty in production. Perhaps use a global flag + `process.env.NODE_ENV !== 'production'`\n     *   to enable it.\n     * - In the case of `onStale()`, we don't control when the user calls\n     *   `getValue()` (as opposed to `onChange()` which calls `getValue()` directly).\n     *   Perhaps we can disable the check in that case.\n     * - Probably the best place to add this check is right here in this method plus some changes to `reportResulutionStart()`,\n     *   which would have to be changed to let the caller know if there is an actual collector (a prism)\n     *   present in its stack.\n     */\n    reportResolutionStart(this)\n\n    const state = this._state\n\n    let val: V\n    if (state.hot) {\n      val = state.handle.getValue()\n    } else {\n      val = calculateColdPrism(this._fn)\n    }\n\n    reportResolutionEnd(this)\n    return val\n  }\n}\n\ninterface PrismScope {\n  effect(key: string, cb: () => () => void, deps?: unknown[]): void\n  memo<T>(\n    key: string,\n    fn: () => T,\n    deps: undefined | $IntentionalAny[] | ReadonlyArray<$IntentionalAny>,\n  ): T\n  state<T>(key: string, initialValue: T): [T, (val: T) => void]\n  ref<T>(key: string, initialValue: T): IRef<T>\n  sub(key: string): PrismScope\n  source<V>(subscribe: (fn: (val: V) => void) => VoidFn, getValue: () => V): V\n}\n\nclass HotScope implements PrismScope {\n  constructor(private readonly _hotHandle: HotHandle<unknown>) {}\n\n  protected readonly _refs: Map<string, IRef<unknown>> = new Map()\n  ref<T>(key: string, initialValue: T): IRef<T> {\n    let ref = this._refs.get(key)\n    if (ref !== undefined) {\n      return ref as $IntentionalAny as IRef<T>\n    } else {\n      const ref = {\n        current: initialValue,\n      }\n      this._refs.set(key, ref)\n      return ref\n    }\n  }\n  isPrismScope = true\n\n  // NOTE probably not a great idea to eager-allocate all of these objects/maps for every scope,\n  // especially because most wouldn't get used in the majority of cases. However, back when these\n  // were stored on weakmaps, they were uncomfortable to inspect in the debugger.\n  readonly subs: Record<string, HotScope> = {}\n  readonly effects: Map<string, IEffect> = new Map()\n\n  effect(key: string, cb: () => () => void, deps?: unknown[]): void {\n    let effect = this.effects.get(key)\n    if (effect === undefined) {\n      effect = {\n        cleanup: voidFn,\n        deps: undefined,\n      }\n      this.effects.set(key, effect)\n    }\n\n    if (depsHaveChanged(effect.deps, deps)) {\n      effect.cleanup()\n\n      startIgnoringDependencies()\n      effect.cleanup = safelyRun(cb, voidFn).value\n      stopIgnoringDependencies()\n      effect.deps = deps\n    }\n    /**\n     * TODO: we should cleanup dangling effects too.\n     * Example:\n     * ```ts\n     * let i = 0\n     * prism(() => {\n     *   if (i === 0) prism.effect(\"this effect will only run once\", () => {}, [])\n     *   i++\n     * })\n     * ```\n     */\n  }\n\n  readonly memos: Map<string, IMemo> = new Map()\n\n  memo<T>(\n    key: string,\n    fn: () => T,\n    deps: undefined | $IntentionalAny[] | ReadonlyArray<$IntentionalAny>,\n  ): T {\n    let memo = this.memos.get(key)\n    if (memo === undefined) {\n      memo = {\n        cachedValue: null,\n        // undefined will always indicate \"deps have changed\", so we set its initial value as such\n        deps: undefined,\n      }\n      this.memos.set(key, memo)\n    }\n\n    if (depsHaveChanged(memo.deps, deps)) {\n      startIgnoringDependencies()\n\n      memo.cachedValue = safelyRun(fn, undefined).value\n      stopIgnoringDependencies()\n      memo.deps = deps\n    }\n\n    return memo.cachedValue as $IntentionalAny as T\n  }\n\n  state<T>(key: string, initialValue: T): [T, (val: T) => void] {\n    const {value, setValue} = this.memo(\n      'state/' + key,\n      () => {\n        const value = {current: initialValue}\n        const setValue = (newValue: T) => {\n          value.current = newValue\n          this._hotHandle.forceStale()\n        }\n        return {value, setValue}\n      },\n      [],\n    )\n\n    return [value.current, setValue]\n  }\n\n  sub(key: string): HotScope {\n    if (!this.subs[key]) {\n      this.subs[key] = new HotScope(this._hotHandle)\n    }\n    return this.subs[key]\n  }\n\n  cleanupEffects() {\n    for (const effect of this.effects.values()) {\n      safelyRun(effect.cleanup, undefined)\n    }\n    this.effects.clear()\n  }\n\n  source<V>(subscribe: (fn: (val: V) => void) => VoidFn, getValue: () => V): V {\n    const sourceKey = '$$source/blah'\n    this.effect(\n      sourceKey,\n      () => {\n        const unsub = subscribe(() => {\n          this._hotHandle.forceStale()\n        })\n        return unsub\n      },\n      [subscribe],\n    )\n    return getValue()\n  }\n}\n\nfunction cleanupScopeStack(scope: HotScope) {\n  for (const sub of Object.values(scope.subs)) {\n    cleanupScopeStack(sub)\n  }\n  scope.cleanupEffects()\n}\n\nfunction safelyRun<T, U>(\n  fn: () => T,\n  returnValueInCaseOfError: U,\n): {ok: true; value: T} | {ok: false; value: U} {\n  try {\n    return {value: fn(), ok: true}\n  } catch (error) {\n    // Naming this function can allow the error reporter additional context to the user on where this error came from\n    setTimeout(function PrismReportThrow() {\n      // ensure that the error gets reported, but does not crash the current execution scope\n      throw error\n    })\n    return {value: returnValueInCaseOfError, ok: false}\n  }\n}\n\nconst hookScopeStack = new Stack<PrismScope>()\n\ntype IRef<T> = {\n  current: T\n}\n\ntype IEffect = {\n  deps: undefined | unknown[]\n  cleanup: VoidFn\n}\n\ntype IMemo = {\n  deps: undefined | unknown[] | ReadonlyArray<unknown>\n  cachedValue: unknown\n}\n\n/**\n * Just like React's `useRef()`, `prism.ref()` allows us to create a prism that holds a reference to some value.\n * The only difference is that `prism.ref()` requires a key to be passed into it, whlie `useRef()` doesn't.\n * This means that we can call `prism.ref()` in any order, and we can call it multiple times with the same key.\n * @param key - The key for the ref. Should be unique inside of the prism.\n * @param initialValue - The initial value for the ref.\n * @returns `{current: V}` - The ref object.\n *\n * Note that the ref object will always return its initial value if the prism is cold. It'll only record\n * its current value if the prism is hot (and will forget again if the prism goes cold again).\n *\n * @example\n * ```ts\n * const pr = prism(() => {\n *   const ref1 = prism.ref(\"ref1\", 0)\n *   console.log(ref1.current) // will print 0, and if the prism is hot, it'll print the current value\n *   ref1.current++ // changing the current value of the ref\n * })\n * ```\n */\nfunction ref<T>(key: string, initialValue: T): IRef<T> {\n  const scope = hookScopeStack.peek()\n  if (!scope) {\n    throw new Error(`prism.ref() is called outside of a prism() call.`)\n  }\n\n  return scope.ref(key, initialValue)\n}\n\n/**\n * An effect hook, similar to React's `useEffect()`, but is not sensitive to call order by using `key`.\n *\n * @param key - the key for the effect. Should be uniqe inside of the prism.\n * @param cb - the callback function. Requires returning a cleanup function.\n * @param deps - the dependency array\n */\nfunction effect(key: string, cb: () => () => void, deps?: unknown[]): void {\n  const scope = hookScopeStack.peek()\n  if (!scope) {\n    throw new Error(`prism.effect() is called outside of a prism() call.`)\n  }\n\n  return scope.effect(key, cb, deps)\n}\n\nfunction depsHaveChanged(\n  oldDeps: undefined | unknown[] | ReadonlyArray<unknown>,\n  newDeps: undefined | unknown[] | ReadonlyArray<unknown>,\n): boolean {\n  if (oldDeps === undefined || newDeps === undefined) {\n    return true\n  }\n\n  const len = oldDeps.length\n  if (len !== newDeps.length) return true\n\n  for (let i = 0; i < len; i++) {\n    if (oldDeps[i] !== newDeps[i]) return true\n  }\n\n  return false\n}\n\n/**\n * `prism.memo()` works just like React's `useMemo()` hook. It's a way to cache the result of a function call.\n * The only difference is that `prism.memo()` requires a key to be passed into it, whlie `useMemo()` doesn't.\n * This means that we can call `prism.memo()` in any order, and we can call it multiple times with the same key.\n *\n * @param key - The key for the memo. Should be unique inside of the prism\n * @param fn - The function to memoize\n * @param deps - The dependency array. Provide `[]` if you want to the value to be memoized only once and never re-calculated.\n * @returns The result of the function call\n *\n * @example\n * ```ts\n * const pr = prism(() => {\n *  const memoizedReturnValueOfExpensiveFn = prism.memo(\"memo1\", expensiveFn, [])\n * })\n * ```\n */\nfunction memo<T>(\n  key: string,\n  fn: () => T,\n  deps: undefined | $IntentionalAny[] | ReadonlyArray<$IntentionalAny>,\n): T {\n  const scope = hookScopeStack.peek()\n  if (!scope) {\n    throw new Error(`prism.memo() is called outside of a prism() call.`)\n  }\n\n  return scope.memo(key, fn, deps)\n}\n\n/**\n * A state hook, similar to react's `useState()`.\n *\n * @param key - the key for the state\n * @param initialValue - the initial value\n * @returns [currentState, setState]\n *\n * @example\n * ```ts\n * import {prism} from 'dataverse'\n *\n * // This prism holds the current mouse position and updates when the mouse moves\n * const mousePositionD = prism(() => {\n *   const [pos, setPos] = prism.state<[x: number, y: number]>('pos', [0, 0])\n *\n *   prism.effect(\n *     'setupListeners',\n *     () => {\n *       const handleMouseMove = (e: MouseEvent) => {\n *         setPos([e.screenX, e.screenY])\n *       }\n *       document.addEventListener('mousemove', handleMouseMove)\n *\n *       return () => {\n *         document.removeEventListener('mousemove', handleMouseMove)\n *       }\n *     },\n *     [],\n *   )\n *\n *   return pos\n * })\n * ```\n */\nfunction state<T>(key: string, initialValue: T): [T, (val: T) => void] {\n  const scope = hookScopeStack.peek()\n  if (!scope) {\n    throw new Error(`prism.state() is called outside of a prism() call.`)\n  }\n\n  return scope.state(key, initialValue)\n}\n\n/**\n * This is useful to make sure your code is running inside a `prism()` call.\n *\n * @example\n * ```ts\n * import {prism} from '@theatre/dataverse'\n *\n * function onlyUsefulInAPrism() {\n *   prism.ensurePrism()\n * }\n *\n * prism(() => {\n *   onlyUsefulInAPrism() // will run fine\n * })\n *\n * setTimeout(() => {\n *   onlyUsefulInAPrism() // throws an error\n *   console.log('This will never get logged')\n * }, 0)\n * ```\n */\nfunction ensurePrism(): void {\n  const scope = hookScopeStack.peek()\n  if (!scope) {\n    throw new Error(`The parent function is called outside of a prism() call.`)\n  }\n}\n\nfunction scope<T>(key: string, fn: () => T): T {\n  const parentScope = hookScopeStack.peek()\n  if (!parentScope) {\n    throw new Error(`prism.scope() is called outside of a prism() call.`)\n  }\n  const subScope = parentScope.sub(key)\n  hookScopeStack.push(subScope)\n  const ret = safelyRun(fn, undefined).value\n  hookScopeStack.pop()\n  return ret as $IntentionalAny as T\n}\n\n/**\n * Just an alias for `prism.memo(key, () => prism(fn), deps).getValue()`. It creates a new prism, memoizes it, and returns the value.\n * `prism.sub()` is useful when you want to divide your prism into smaller prisms, each of which\n * would _only_ recalculate when _certain_ dependencies change. In other words, it's an optimization tool.\n *\n * @param key - The key for the memo. Should be unique inside of the prism\n * @param fn - The function to run inside the prism\n * @param deps - The dependency array. Provide `[]` if you want to the value to be memoized only once and never re-calculated.\n * @returns The value of the inner prism\n */\nfunction sub<T>(\n  key: string,\n  fn: () => T,\n  deps: undefined | $IntentionalAny[],\n): T {\n  return memo(key, () => prism(fn), deps).getValue()\n}\n\n/**\n * @returns true if the current function is running inside a `prism()` call.\n */\nfunction inPrism(): boolean {\n  return !!hookScopeStack.peek()\n}\n\nconst possiblePrismToValue = <P extends Prism<$IntentionalAny> | unknown>(\n  input: P,\n): P extends Prism<infer T> ? T : P => {\n  if (isPrism(input)) {\n    return input.getValue() as $IntentionalAny\n  } else {\n    return input as $IntentionalAny\n  }\n}\n\n/**\n * `prism.source()`  allow a prism to react to changes in some external source (other than other prisms).\n * For example, `Atom.pointerToPrism()` uses `prism.source()` to create a prism that reacts to changes in the atom's value.\n \n * @param subscribe - The prism will call this function as soon as the prism goes hot. This function should return an unsubscribe function function which the prism will call when it goes cold.\n * @param getValue - A function that returns the current value of the external source.\n * @returns The current value of the source\n * \n * Example:\n * ```ts\n * function prismFromInputElement(input: HTMLInputElement): Prism<string> {\n *   function listen(cb: (value: string) => void) {\n *     const listener = () => {\n *       cb(input.value)\n *     }\n *     input.addEventListener('input', listener)\n *     return () => {\n *       input.removeEventListener('input', listener)\n *     }\n *   }\n *   \n *   function get() {\n *     return input.value\n *   }\n *   return prism(() => prism.source(listen, get))\n * }\n * ```\n */\nfunction source<V>(\n  subscribe: (fn: (val: V) => void) => VoidFn,\n  getValue: () => V,\n): V {\n  const scope = hookScopeStack.peek()\n  if (!scope) {\n    throw new Error(`prism.source() is called outside of a prism() call.`)\n  }\n\n  return scope.source(subscribe, getValue)\n}\n\ntype IPrismFn = {\n  <T>(fn: () => T): Prism<T>\n  ref: typeof ref\n  effect: typeof effect\n  memo: typeof memo\n  ensurePrism: typeof ensurePrism\n  state: typeof state\n  scope: typeof scope\n  sub: typeof sub\n  inPrism: typeof inPrism\n  source: typeof source\n}\n\n/**\n * Creates a prism from the passed function that adds all prisms referenced\n * in it as dependencies, and reruns the function when these change.\n *\n * @param fn - The function to rerun when the prisms referenced in it change.\n */\nconst prism: IPrismFn = (fn) => {\n  return new PrismInstance(fn)\n}\n\nclass ColdScope implements PrismScope {\n  effect(key: string, cb: () => () => void, deps?: unknown[]): void {\n    console.warn(`prism.effect() does not run in cold prisms`)\n  }\n  memo<T>(\n    key: string,\n    fn: () => T,\n    deps: any[] | readonly any[] | undefined,\n  ): T {\n    return fn()\n  }\n  state<T>(key: string, initialValue: T): [T, (val: T) => void] {\n    return [initialValue, () => {}]\n  }\n  ref<T>(key: string, initialValue: T): IRef<T> {\n    return {current: initialValue}\n  }\n  sub(key: string): ColdScope {\n    return new ColdScope()\n  }\n  source<V>(subscribe: (fn: (val: V) => void) => VoidFn, getValue: () => V): V {\n    return getValue()\n  }\n}\n\nfunction calculateColdPrism<V>(fn: () => V): V {\n  const scope = new ColdScope()\n  hookScopeStack.push(scope)\n  let value: V\n  try {\n    value = fn()\n  } catch (error) {\n    console.error(error)\n  } finally {\n    const topOfTheStack = hookScopeStack.pop()\n    if (topOfTheStack !== scope) {\n      console.warn(\n        // @todo guide the user to report the bug in an issue\n        `The Prism hook stack has slipped. This is a bug.`,\n      )\n    }\n  }\n  return value!\n}\n\nprism.ref = ref\nprism.effect = effect\nprism.memo = memo\nprism.ensurePrism = ensurePrism\nprism.state = state\nprism.scope = scope\nprism.sub = sub\nprism.inPrism = inPrism\nprism.source = source\n\nexport default prism\n","import get from 'lodash-es/get'\nimport isPlainObject from 'lodash-es/isPlainObject'\nimport last from 'lodash-es/last'\nimport type {Prism} from './prism/Interface'\nimport type {Pointer} from './pointer'\nimport {getPointerParts} from './pointer'\nimport {isPointer} from './pointer'\nimport pointer from './pointer'\nimport type {$FixMe, $IntentionalAny} from './types'\nimport updateDeep from './utils/updateDeep'\nimport prism from './prism/prism'\nimport type {PointerToPrismProvider} from './pointerToPrism'\n\ntype Listener = (newVal: unknown) => void\n\nenum ValueTypes {\n  Dict,\n  Array,\n  Other,\n}\n\nconst getTypeOfValue = (v: unknown): ValueTypes => {\n  if (Array.isArray(v)) return ValueTypes.Array\n  if (isPlainObject(v)) return ValueTypes.Dict\n  return ValueTypes.Other\n}\n\nconst getKeyOfValue = (\n  v: unknown,\n  key: string | number,\n  vType: ValueTypes = getTypeOfValue(v),\n): unknown => {\n  if (vType === ValueTypes.Dict && typeof key === 'string') {\n    return (v as $IntentionalAny)[key]\n  } else if (vType === ValueTypes.Array && isValidArrayIndex(key)) {\n    return (v as $IntentionalAny)[key]\n  } else {\n    return undefined\n  }\n}\n\nconst isValidArrayIndex = (key: string | number): boolean => {\n  const inNumber = typeof key === 'number' ? key : parseInt(key, 10)\n  return (\n    !isNaN(inNumber) &&\n    inNumber >= 0 &&\n    inNumber < Infinity &&\n    (inNumber | 0) === inNumber\n  )\n}\n\nclass Scope {\n  children: Map<string | number, Scope> = new Map()\n  identityChangeListeners: Set<Listener> = new Set()\n  constructor(\n    readonly _parent: undefined | Scope,\n    readonly _path: (string | number)[],\n  ) {}\n\n  addIdentityChangeListener(cb: Listener) {\n    this.identityChangeListeners.add(cb)\n  }\n\n  removeIdentityChangeListener(cb: Listener) {\n    this.identityChangeListeners.delete(cb)\n    this._checkForGC()\n  }\n\n  removeChild(key: string | number) {\n    this.children.delete(key)\n    this._checkForGC()\n  }\n\n  getChild(key: string | number) {\n    return this.children.get(key)\n  }\n\n  getOrCreateChild(key: string | number) {\n    let child = this.children.get(key)\n    if (!child) {\n      child = child = new Scope(this, this._path.concat([key]))\n      this.children.set(key, child)\n    }\n    return child\n  }\n\n  _checkForGC() {\n    if (this.identityChangeListeners.size > 0) return\n    if (this.children.size > 0) return\n\n    if (this._parent) {\n      this._parent.removeChild(last(this._path) as string | number)\n    }\n  }\n}\n\n/**\n * Wraps an object whose (sub)properties can be individually tracked.\n */\nexport default class Atom<State> implements PointerToPrismProvider {\n  private _currentState: State\n  /**\n   * @internal\n   */\n  readonly $$isPointerToPrismProvider = true\n  private readonly _rootScope: Scope\n  /**\n   * Convenience property that gives you a pointer to the root of the atom.\n   *\n   * @remarks\n   * Equivalent to `pointer({ root: thisAtom, path: [] })`.\n   */\n  readonly pointer: Pointer<State> = pointer({root: this as $FixMe, path: []})\n\n  readonly prism: Prism<State> = this.pointerToPrism(\n    this.pointer,\n  ) as $IntentionalAny\n\n  constructor(initialState: State) {\n    this._currentState = initialState\n    this._rootScope = new Scope(undefined, [])\n  }\n\n  /**\n   * Sets the state of the atom.\n   *\n   * @param newState - The new state of the atom.\n   */\n  set(newState: State) {\n    const oldState = this._currentState\n    this._currentState = newState\n\n    this._checkUpdates(this._rootScope, oldState, newState)\n  }\n\n  get(): State {\n    return this._currentState\n  }\n\n  /**\n   * Returns the value at the given pointer\n   *\n   * @param pointerOrFn - A pointer to the desired path. Could also be a function returning a pointer\n   *\n   * Example\n   * ```ts\n   * const atom = atom({ a: { b: 1 } })\n   * atom.getByPointer(atom.pointer.a.b) // 1\n   * atom.getByPointer((p) => p.a.b) // 1\n   * ```\n   */\n  getByPointer<S>(\n    pointerOrFn: Pointer<S> | ((p: Pointer<State>) => Pointer<S>),\n  ): S {\n    const pointer = isPointer(pointerOrFn)\n      ? pointerOrFn\n      : (pointerOrFn as $IntentionalAny)(this.pointer)\n\n    const path = getPointerParts(pointer).path\n    return this._getIn(path) as S\n  }\n\n  /**\n   * Gets the state of the atom at `path`.\n   */\n  private _getIn(path: (string | number)[]): unknown {\n    return path.length === 0 ? this.get() : get(this.get(), path)\n  }\n\n  reduce(fn: (state: State) => State) {\n    this.set(fn(this.get()))\n  }\n\n  /**\n   * Reduces the value at the given pointer\n   *\n   * @param pointerOrFn - A pointer to the desired path. Could also be a function returning a pointer\n   *\n   * Example\n   * ```ts\n   * const atom = atom({ a: { b: 1 } })\n   * atom.reduceByPointer(atom.pointer.a.b, (b) => b + 1) // atom.get().a.b === 2\n   * atom.reduceByPointer((p) => p.a.b, (b) => b + 1) // atom.get().a.b === 2\n   * ```\n   */\n  reduceByPointer<S>(\n    pointerOrFn: Pointer<S> | ((p: Pointer<State>) => Pointer<S>),\n    reducer: (s: S) => S,\n  ) {\n    const pointer = isPointer(pointerOrFn)\n      ? pointerOrFn\n      : (pointerOrFn as $IntentionalAny)(this.pointer)\n\n    const path = getPointerParts(pointer).path\n    const newState = updateDeep(this.get(), path, reducer)\n    this.set(newState)\n  }\n\n  /**\n   * Sets the value at the given pointer\n   *\n   * @param pointerOrFn - A pointer to the desired path. Could also be a function returning a pointer\n   *\n   * Example\n   * ```ts\n   * const atom = atom({ a: { b: 1 } })\n   * atom.setByPointer(atom.pointer.a.b, 2) // atom.get().a.b === 2\n   * atom.setByPointer((p) => p.a.b, 2) // atom.get().a.b === 2\n   * ```\n   */\n  setByPointer<S>(\n    pointerOrFn: Pointer<S> | ((p: Pointer<State>) => Pointer<S>),\n    val: S,\n  ) {\n    this.reduceByPointer(pointerOrFn, () => val)\n  }\n\n  private _checkUpdates(scope: Scope, oldState: unknown, newState: unknown) {\n    if (oldState === newState) return\n    for (const cb of scope.identityChangeListeners) {\n      cb(newState)\n    }\n\n    if (scope.children.size === 0) return\n\n    // @todo we can probably skip checking value types\n    const oldValueType = getTypeOfValue(oldState)\n    const newValueType = getTypeOfValue(newState)\n\n    if (oldValueType === ValueTypes.Other && oldValueType === newValueType)\n      return\n\n    for (const [childKey, childScope] of scope.children) {\n      const oldChildVal = getKeyOfValue(oldState, childKey, oldValueType)\n      const newChildVal = getKeyOfValue(newState, childKey, newValueType)\n      this._checkUpdates(childScope, oldChildVal, newChildVal)\n    }\n  }\n\n  private _getOrCreateScopeForPath(path: (string | number)[]): Scope {\n    let curScope = this._rootScope\n    for (const pathEl of path) {\n      curScope = curScope.getOrCreateChild(pathEl)\n    }\n    return curScope\n  }\n\n  private _onPointerValueChange = <P>(\n    pointer: Pointer<P>,\n    cb: (v: P) => void,\n  ): (() => void) => {\n    const {path} = getPointerParts(pointer)\n    const scope = this._getOrCreateScopeForPath(path)\n    scope.identityChangeListeners.add(cb as $IntentionalAny)\n    const unsubscribe = () => {\n      scope.identityChangeListeners.delete(cb as $IntentionalAny)\n    }\n    return unsubscribe\n  }\n\n  /**\n   * Returns a new prism of the value at the provided path.\n   *\n   * @param pointer - The path to create the prism at.\n   *\n   * ```ts\n   * const pr = atom({ a: { b: 1 } }).pointerToPrism(atom.pointer.a.b)\n   * pr.getValue() // 1\n   * ```\n   */\n  pointerToPrism<P>(pointer: Pointer<P>): Prism<P> {\n    const {path} = getPointerParts(pointer)\n    const subscribe = (listener: (val: unknown) => void) =>\n      this._onPointerValueChange(pointer, listener)\n\n    const getValue = () => this._getIn(path)\n\n    return prism(() => {\n      return prism.source(subscribe, getValue)\n    }) as Prism<P>\n  }\n}\n","import type {Prism} from './prism/Interface'\nimport type {Pointer, PointerType} from './pointer'\nimport {getPointerMeta} from './pointer'\nimport type {$IntentionalAny} from './types'\n\nconst identifyPrismWeakMap = new WeakMap<{}, Prism<unknown>>()\n\n/**\n * Interface for objects that can provide a prism at a certain path.\n */\nexport interface PointerToPrismProvider {\n  /**\n   * @internal\n   * Future: We could consider using a `Symbol.for(\"dataverse/PointerToPrismProvider\")` as a key here, similar to\n   * how {@link Iterable} works for `of`.\n   */\n  readonly $$isPointerToPrismProvider: true\n  /**\n   * Returns a prism of the value at the provided pointer.\n   */\n  pointerToPrism<P>(pointer: Pointer<P>): Prism<P>\n}\n\nexport function isPointerToPrismProvider(\n  val: unknown,\n): val is PointerToPrismProvider {\n  return (\n    typeof val === 'object' &&\n    val !== null &&\n    (val as $IntentionalAny)['$$isPointerToPrismProvider'] === true\n  )\n}\n\n/**\n * Returns a prism of the value at the provided pointer. Prisms are\n * cached per pointer.\n *\n * @param pointer - The pointer to return the prism at.\n */\n\nexport const pointerToPrism = <P extends PointerType<$IntentionalAny>>(\n  pointer: P,\n): Prism<P extends PointerType<infer T> ? T : void> => {\n  const meta = getPointerMeta(pointer)\n\n  let prismInstance = identifyPrismWeakMap.get(meta)\n  if (!prismInstance) {\n    const root = meta.root\n    if (!isPointerToPrismProvider(root)) {\n      throw new Error(\n        `Cannot run pointerToPrism() on a pointer whose root is not an PointerToPrismProvider`,\n      )\n    }\n    prismInstance = root.pointerToPrism(pointer as $IntentionalAny)\n    identifyPrismWeakMap.set(meta, prismInstance)\n  }\n  return prismInstance as $IntentionalAny\n}\n","import type {Prism} from './prism/Interface'\nimport {isPrism} from './prism/Interface'\nimport type {PointerType} from './pointer'\nimport {isPointer} from './pointer'\nimport type {$IntentionalAny} from './types'\nimport {pointerToPrism} from './pointerToPrism'\n\n/**\n * Convenience function that returns a plain value from its argument, whether it\n * is a pointer, a prism or a plain value itself.\n *\n * @remarks\n * For pointers, the value is returned by first creating a prism, so it is\n * reactive e.g. when used in a `prism`.\n *\n * @param input - The argument to return a value from.\n */\n\nexport const val = <\n  P extends\n    | PointerType<$IntentionalAny>\n    | Prism<$IntentionalAny>\n    | undefined\n    | null,\n>(\n  input: P,\n): P extends PointerType<infer T>\n  ? T\n  : P extends Prism<infer T>\n  ? T\n  : P extends undefined | null\n  ? P\n  : unknown => {\n  if (isPointer(input)) {\n    return pointerToPrism(input).getValue() as $IntentionalAny\n  } else if (isPrism(input)) {\n    return input.getValue() as $IntentionalAny\n  } else {\n    return input as $IntentionalAny\n  }\n}\n","import {pointerToPrism} from '../pointerToPrism'\nimport type {Pointer} from '../pointer'\nimport {isPointer} from '../pointer'\nimport type {Prism} from './Interface'\nimport {isPrism} from './Interface'\n\nexport default function* iterateAndCountTicks<V>(\n  pointerOrPrism: Prism<V> | Pointer<V>,\n): Generator<{value: V; ticks: number}, void, void> {\n  let d\n  if (isPointer(pointerOrPrism)) {\n    d = pointerToPrism(pointerOrPrism) as Prism<V>\n  } else if (isPrism(pointerOrPrism)) {\n    d = pointerOrPrism\n  } else {\n    throw new Error(`Only pointers and prisms are supported`)\n  }\n\n  let ticksCountedSinceLastYield = 0\n  const untap = d.onStale(() => {\n    ticksCountedSinceLastYield++\n  })\n\n  try {\n    while (true) {\n      const ticks = ticksCountedSinceLastYield\n      ticksCountedSinceLastYield = 0\n      yield {value: d.getValue(), ticks}\n    }\n  } finally {\n    untap()\n  }\n}\n","type ICallback = (t: number) => void\n\n/**\n * The number of ticks that can pass without any scheduled callbacks before the Ticker goes dormant. This is to prevent\n * the Ticker from staying active forever, even if there are no scheduled callbacks.\n *\n * Perhaps counting ticks vs. time is not the best way to do this. But it's a start.\n */\nexport const EMPTY_TICKS_BEFORE_GOING_DORMANT = 60 /*fps*/ * 3 /*seconds*/ // on a 60fps screen, 3 seconds should pass before the ticker goes dormant\n\n/**\n * The Ticker class helps schedule callbacks. Scheduled callbacks are executed per tick. Ticks can be triggered by an\n * external scheduling strategy, e.g. a raf.\n */\nexport default class Ticker {\n  private _scheduledForThisOrNextTick: Set<ICallback>\n  private _scheduledForNextTick: Set<ICallback>\n  private _timeAtCurrentTick: number\n  private _ticking: boolean = false\n\n  /**\n   * Whether the Ticker is dormant\n   */\n  private _dormant: boolean = true\n\n  private _numberOfDormantTicks = 0\n\n  /**\n   * Whether the Ticker is dormant\n   */\n  get dormant(): boolean {\n    return this._dormant\n  }\n  /**\n   * Counts up for every tick executed.\n   * Internally, this is used to measure ticks per second.\n   *\n   * This is \"public\" to TypeScript, because it's a tool for performance measurements.\n   * Consider this as experimental, and do not rely on it always being here in future releases.\n   */\n  public __ticks = 0\n\n  constructor(\n    private _conf?: {\n      /**\n       * This is called when the Ticker goes dormant.\n       */\n      onDormant?: () => void\n      /**\n       * This is called when the Ticker goes active.\n       */\n      onActive?: () => void\n    },\n  ) {\n    this._scheduledForThisOrNextTick = new Set()\n    this._scheduledForNextTick = new Set()\n    this._timeAtCurrentTick = 0\n  }\n\n  /**\n   * Registers for fn to be called either on this tick or the next tick.\n   *\n   * If `onThisOrNextTick()` is called while `Ticker.tick()` is running, the\n   * side effect _will_ be called within the running tick. If you don't want this\n   * behavior, you can use `onNextTick()`.\n   *\n   * Note that `fn` will be added to a `Set()`. Which means, if you call `onThisOrNextTick(fn)`\n   * with the same fn twice in a single tick, it'll only run once.\n   *\n   * @param fn - The function to be registered.\n   *\n   * @see offThisOrNextTick\n   */\n  onThisOrNextTick(fn: ICallback) {\n    this._scheduledForThisOrNextTick.add(fn)\n    if (this._dormant) {\n      this._goActive()\n    }\n  }\n\n  /**\n   * Registers a side effect to be called on the next tick.\n   *\n   * @param fn - The function to be registered.\n   *\n   * @see onThisOrNextTick\n   * @see offNextTick\n   */\n  onNextTick(fn: ICallback) {\n    this._scheduledForNextTick.add(fn)\n    if (this._dormant) {\n      this._goActive()\n    }\n  }\n\n  /**\n   * De-registers a fn to be called either on this tick or the next tick.\n   *\n   * @param fn - The function to be de-registered.\n   *\n   * @see onThisOrNextTick\n   */\n  offThisOrNextTick(fn: ICallback) {\n    this._scheduledForThisOrNextTick.delete(fn)\n  }\n\n  /**\n   * De-registers a fn to be called on the next tick.\n   *\n   * @param fn - The function to be de-registered.\n   *\n   * @see onNextTick\n   */\n  offNextTick(fn: ICallback) {\n    this._scheduledForNextTick.delete(fn)\n  }\n\n  /**\n   * The time at the start of the current tick if there is a tick in progress, otherwise defaults to\n   * `performance.now()`.\n   */\n  get time() {\n    if (this._ticking) {\n      return this._timeAtCurrentTick\n    } else return performance.now()\n  }\n\n  private _goActive() {\n    if (!this._dormant) return\n    this._dormant = false\n    this._conf?.onActive?.()\n  }\n\n  private _goDormant() {\n    if (this._dormant) return\n    this._dormant = true\n    this._numberOfDormantTicks = 0\n    this._conf?.onDormant?.()\n  }\n\n  /**\n   * Triggers a tick which starts executing the callbacks scheduled for this tick.\n   *\n   * @param t - The time at the tick.\n   *\n   * @see onThisOrNextTick\n   * @see onNextTick\n   */\n  tick(t: number = performance.now()) {\n    if (process.env.NODE_ENV === 'development') {\n      if (!(this instanceof Ticker)) {\n        throw new Error(\n          'ticker.tick must be called while bound to the ticker. As in, \"ticker.tick(time)\" or \"requestAnimationFrame((t) => ticker.tick(t))\" for performance.',\n        )\n      }\n    }\n\n    this.__ticks++\n\n    if (!this._dormant) {\n      if (\n        this._scheduledForNextTick.size === 0 &&\n        this._scheduledForThisOrNextTick.size === 0\n      ) {\n        this._numberOfDormantTicks++\n        if (this._numberOfDormantTicks >= EMPTY_TICKS_BEFORE_GOING_DORMANT) {\n          this._goDormant()\n          return\n        }\n      }\n    }\n\n    this._ticking = true\n    this._timeAtCurrentTick = t\n    for (const v of this._scheduledForNextTick) {\n      this._scheduledForThisOrNextTick.add(v)\n    }\n\n    this._scheduledForNextTick.clear()\n    this._tick(0)\n    this._ticking = false\n  }\n\n  private _tick(iterationNumber: number): void {\n    const time = this.time\n\n    if (iterationNumber > 10) {\n      console.warn('_tick() recursing for 10 times')\n    }\n\n    if (iterationNumber > 100) {\n      throw new Error(`Maximum recursion limit for _tick()`)\n    }\n\n    const oldSet = this._scheduledForThisOrNextTick\n    this._scheduledForThisOrNextTick = new Set()\n    for (const fn of oldSet) {\n      fn(time)\n    }\n\n    if (this._scheduledForThisOrNextTick.size > 0) {\n      return this._tick(iterationNumber + 1)\n    }\n  }\n}\n","import {pointerToPrism} from '../pointerToPrism'\nimport type {Pointer} from '../pointer'\nimport {isPointer} from '../pointer'\nimport Ticker from '../Ticker'\nimport type {Prism} from './Interface'\nimport {isPrism} from './Interface'\n\nexport default function* iterateOver<V>(\n  pointerOrPrism: Prism<V> | Pointer<V>,\n): Generator<V, void, void> {\n  let d\n  if (isPointer(pointerOrPrism)) {\n    d = pointerToPrism(pointerOrPrism) as Prism<V>\n  } else if (isPrism(pointerOrPrism)) {\n    d = pointerOrPrism\n  } else {\n    throw new Error(`Only pointers and prisms are supported`)\n  }\n\n  const ticker = new Ticker()\n\n  const untap = d.onChange(ticker, (v) => {})\n\n  try {\n    while (true) {\n      ticker.tick()\n\n      yield d.getValue()\n    }\n  } finally {\n    untap()\n  }\n}\n","import Atom from './Atom'\nimport {val} from './val'\nimport type {Pointer} from './pointer'\nimport {getPointerMeta} from './pointer'\nimport pointer from './pointer'\nimport type {$FixMe, $IntentionalAny} from './types'\nimport prism from './prism/prism'\nimport type {Prism} from './prism/Interface'\nimport type {PointerToPrismProvider} from './pointerToPrism'\n\n/**\n * Allows creating pointer-prisms where the pointer can be switched out.\n *\n * @remarks\n * This allows reacting not just to value changes at a certain pointer, but changes\n * to the proxied pointer too.\n */\nexport default class PointerProxy<O extends {}>\n  implements PointerToPrismProvider\n{\n  /**\n   * @internal\n   */\n  readonly $$isPointerToPrismProvider = true\n  private readonly _currentPointerBox: Atom<Pointer<O>>\n  /**\n   * Convenience pointer pointing to the root of this PointerProxy.\n   *\n   * @remarks\n   * Allows convenient use of {@link pointerToPrism} and {@link val}.\n   */\n  readonly pointer: Pointer<O>\n\n  constructor(currentPointer: Pointer<O>) {\n    this._currentPointerBox = new Atom(currentPointer)\n    this.pointer = pointer({root: this as $FixMe, path: []})\n  }\n\n  /**\n   * Sets the underlying pointer.\n   * @param p - The pointer to be proxied.\n   */\n  setPointer(p: Pointer<O>) {\n    this._currentPointerBox.set(p)\n  }\n\n  /**\n   * Returns a prism of the value at the provided sub-path of the proxied pointer.\n   *\n   * @param path - The path to create the prism at.\n   */\n  pointerToPrism<P>(pointer: Pointer<P>): Prism<P> {\n    const {path} = getPointerMeta(pointer)\n    return prism(() => {\n      const currentPointer = this._currentPointerBox.prism.getValue()\n      const subPointer = path.reduce(\n        (pointerSoFar, pathItem) => (pointerSoFar as $IntentionalAny)[pathItem],\n        currentPointer,\n      )\n      return val(subPointer) as P\n    })\n  }\n}\n"]},"metadata":{},"sourceType":"script"}