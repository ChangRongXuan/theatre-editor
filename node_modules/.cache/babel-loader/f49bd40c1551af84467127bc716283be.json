{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __markAsModule = target => __defProp(target, \"__esModule\", {\n  value: true\n});\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all) __defProp(target, name, {\n    get: all[name],\n    enumerable: true\n  });\n};\n\n// src/index.ts\n__export(exports, {\n  Atom: () => Atom,\n  PointerProxy: () => PointerProxy,\n  Ticker: () => Ticker,\n  getPointerParts: () => getPointerParts,\n  isPointer: () => isPointer,\n  isPrism: () => isPrism,\n  iterateAndCountTicks: () => iterateAndCountTicks,\n  iterateOver: () => iterateOver,\n  pointer: () => pointer_default,\n  pointerToPrism: () => pointerToPrism,\n  prism: () => prism_default,\n  val: () => val\n});\n\n// ../../node_modules/lodash-es/isArray.js\nvar isArray = Array.isArray;\nvar isArray_default = isArray;\n\n// ../../node_modules/lodash-es/_freeGlobal.js\nvar freeGlobal = typeof global == \"object\" && global && global.Object === Object && global;\nvar freeGlobal_default = freeGlobal;\n\n// ../../node_modules/lodash-es/_root.js\nvar freeSelf = typeof self == \"object\" && self && self.Object === Object && self;\nvar root = freeGlobal_default || freeSelf || Function(\"return this\")();\nvar root_default = root;\n\n// ../../node_modules/lodash-es/_Symbol.js\nvar Symbol2 = root_default.Symbol;\nvar Symbol_default = Symbol2;\n\n// ../../node_modules/lodash-es/_getRawTag.js\nvar objectProto = Object.prototype;\nvar hasOwnProperty = objectProto.hasOwnProperty;\nvar nativeObjectToString = objectProto.toString;\nvar symToStringTag = Symbol_default ? Symbol_default.toStringTag : void 0;\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n    tag = value[symToStringTag];\n  try {\n    value[symToStringTag] = void 0;\n    var unmasked = true;\n  } catch (e) {}\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\nvar getRawTag_default = getRawTag;\n\n// ../../node_modules/lodash-es/_objectToString.js\nvar objectProto2 = Object.prototype;\nvar nativeObjectToString2 = objectProto2.toString;\nfunction objectToString(value) {\n  return nativeObjectToString2.call(value);\n}\nvar objectToString_default = objectToString;\n\n// ../../node_modules/lodash-es/_baseGetTag.js\nvar nullTag = \"[object Null]\";\nvar undefinedTag = \"[object Undefined]\";\nvar symToStringTag2 = Symbol_default ? Symbol_default.toStringTag : void 0;\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === void 0 ? undefinedTag : nullTag;\n  }\n  return symToStringTag2 && symToStringTag2 in Object(value) ? getRawTag_default(value) : objectToString_default(value);\n}\nvar baseGetTag_default = baseGetTag;\n\n// ../../node_modules/lodash-es/isObjectLike.js\nfunction isObjectLike(value) {\n  return value != null && typeof value == \"object\";\n}\nvar isObjectLike_default = isObjectLike;\n\n// ../../node_modules/lodash-es/isSymbol.js\nvar symbolTag = \"[object Symbol]\";\nfunction isSymbol(value) {\n  return typeof value == \"symbol\" || isObjectLike_default(value) && baseGetTag_default(value) == symbolTag;\n}\nvar isSymbol_default = isSymbol;\n\n// ../../node_modules/lodash-es/_isKey.js\nvar reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/;\nvar reIsPlainProp = /^\\w*$/;\nfunction isKey(value, object) {\n  if (isArray_default(value)) {\n    return false;\n  }\n  var type = typeof value;\n  if (type == \"number\" || type == \"symbol\" || type == \"boolean\" || value == null || isSymbol_default(value)) {\n    return true;\n  }\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);\n}\nvar isKey_default = isKey;\n\n// ../../node_modules/lodash-es/isObject.js\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == \"object\" || type == \"function\");\n}\nvar isObject_default = isObject;\n\n// ../../node_modules/lodash-es/isFunction.js\nvar asyncTag = \"[object AsyncFunction]\";\nvar funcTag = \"[object Function]\";\nvar genTag = \"[object GeneratorFunction]\";\nvar proxyTag = \"[object Proxy]\";\nfunction isFunction(value) {\n  if (!isObject_default(value)) {\n    return false;\n  }\n  var tag = baseGetTag_default(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\nvar isFunction_default = isFunction;\n\n// ../../node_modules/lodash-es/_coreJsData.js\nvar coreJsData = root_default[\"__core-js_shared__\"];\nvar coreJsData_default = coreJsData;\n\n// ../../node_modules/lodash-es/_isMasked.js\nvar maskSrcKey = function () {\n  var uid = /[^.]+$/.exec(coreJsData_default && coreJsData_default.keys && coreJsData_default.keys.IE_PROTO || \"\");\n  return uid ? \"Symbol(src)_1.\" + uid : \"\";\n}();\nfunction isMasked(func) {\n  return !!maskSrcKey && maskSrcKey in func;\n}\nvar isMasked_default = isMasked;\n\n// ../../node_modules/lodash-es/_toSource.js\nvar funcProto = Function.prototype;\nvar funcToString = funcProto.toString;\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return func + \"\";\n    } catch (e) {}\n  }\n  return \"\";\n}\nvar toSource_default = toSource;\n\n// ../../node_modules/lodash-es/_baseIsNative.js\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\nvar funcProto2 = Function.prototype;\nvar objectProto3 = Object.prototype;\nvar funcToString2 = funcProto2.toString;\nvar hasOwnProperty2 = objectProto3.hasOwnProperty;\nvar reIsNative = RegExp(\"^\" + funcToString2.call(hasOwnProperty2).replace(reRegExpChar, \"\\\\$&\").replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, \"$1.*?\") + \"$\");\nfunction baseIsNative(value) {\n  if (!isObject_default(value) || isMasked_default(value)) {\n    return false;\n  }\n  var pattern = isFunction_default(value) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource_default(value));\n}\nvar baseIsNative_default = baseIsNative;\n\n// ../../node_modules/lodash-es/_getValue.js\nfunction getValue(object, key) {\n  return object == null ? void 0 : object[key];\n}\nvar getValue_default = getValue;\n\n// ../../node_modules/lodash-es/_getNative.js\nfunction getNative(object, key) {\n  var value = getValue_default(object, key);\n  return baseIsNative_default(value) ? value : void 0;\n}\nvar getNative_default = getNative;\n\n// ../../node_modules/lodash-es/_nativeCreate.js\nvar nativeCreate = getNative_default(Object, \"create\");\nvar nativeCreate_default = nativeCreate;\n\n// ../../node_modules/lodash-es/_hashClear.js\nfunction hashClear() {\n  this.__data__ = nativeCreate_default ? nativeCreate_default(null) : {};\n  this.size = 0;\n}\nvar hashClear_default = hashClear;\n\n// ../../node_modules/lodash-es/_hashDelete.js\nfunction hashDelete(key) {\n  var result = this.has(key) && delete this.__data__[key];\n  this.size -= result ? 1 : 0;\n  return result;\n}\nvar hashDelete_default = hashDelete;\n\n// ../../node_modules/lodash-es/_hashGet.js\nvar HASH_UNDEFINED = \"__lodash_hash_undefined__\";\nvar objectProto4 = Object.prototype;\nvar hasOwnProperty3 = objectProto4.hasOwnProperty;\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate_default) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? void 0 : result;\n  }\n  return hasOwnProperty3.call(data, key) ? data[key] : void 0;\n}\nvar hashGet_default = hashGet;\n\n// ../../node_modules/lodash-es/_hashHas.js\nvar objectProto5 = Object.prototype;\nvar hasOwnProperty4 = objectProto5.hasOwnProperty;\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate_default ? data[key] !== void 0 : hasOwnProperty4.call(data, key);\n}\nvar hashHas_default = hashHas;\n\n// ../../node_modules/lodash-es/_hashSet.js\nvar HASH_UNDEFINED2 = \"__lodash_hash_undefined__\";\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  this.size += this.has(key) ? 0 : 1;\n  data[key] = nativeCreate_default && value === void 0 ? HASH_UNDEFINED2 : value;\n  return this;\n}\nvar hashSet_default = hashSet;\n\n// ../../node_modules/lodash-es/_Hash.js\nfunction Hash(entries) {\n  var index = -1,\n    length = entries == null ? 0 : entries.length;\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\nHash.prototype.clear = hashClear_default;\nHash.prototype[\"delete\"] = hashDelete_default;\nHash.prototype.get = hashGet_default;\nHash.prototype.has = hashHas_default;\nHash.prototype.set = hashSet_default;\nvar Hash_default = Hash;\n\n// ../../node_modules/lodash-es/_listCacheClear.js\nfunction listCacheClear() {\n  this.__data__ = [];\n  this.size = 0;\n}\nvar listCacheClear_default = listCacheClear;\n\n// ../../node_modules/lodash-es/eq.js\nfunction eq(value, other) {\n  return value === other || value !== value && other !== other;\n}\nvar eq_default = eq;\n\n// ../../node_modules/lodash-es/_assocIndexOf.js\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq_default(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\nvar assocIndexOf_default = assocIndexOf;\n\n// ../../node_modules/lodash-es/_listCacheDelete.js\nvar arrayProto = Array.prototype;\nvar splice = arrayProto.splice;\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n    index = assocIndexOf_default(data, key);\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  --this.size;\n  return true;\n}\nvar listCacheDelete_default = listCacheDelete;\n\n// ../../node_modules/lodash-es/_listCacheGet.js\nfunction listCacheGet(key) {\n  var data = this.__data__,\n    index = assocIndexOf_default(data, key);\n  return index < 0 ? void 0 : data[index][1];\n}\nvar listCacheGet_default = listCacheGet;\n\n// ../../node_modules/lodash-es/_listCacheHas.js\nfunction listCacheHas(key) {\n  return assocIndexOf_default(this.__data__, key) > -1;\n}\nvar listCacheHas_default = listCacheHas;\n\n// ../../node_modules/lodash-es/_listCacheSet.js\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n    index = assocIndexOf_default(data, key);\n  if (index < 0) {\n    ++this.size;\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\nvar listCacheSet_default = listCacheSet;\n\n// ../../node_modules/lodash-es/_ListCache.js\nfunction ListCache(entries) {\n  var index = -1,\n    length = entries == null ? 0 : entries.length;\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\nListCache.prototype.clear = listCacheClear_default;\nListCache.prototype[\"delete\"] = listCacheDelete_default;\nListCache.prototype.get = listCacheGet_default;\nListCache.prototype.has = listCacheHas_default;\nListCache.prototype.set = listCacheSet_default;\nvar ListCache_default = ListCache;\n\n// ../../node_modules/lodash-es/_Map.js\nvar Map2 = getNative_default(root_default, \"Map\");\nvar Map_default = Map2;\n\n// ../../node_modules/lodash-es/_mapCacheClear.js\nfunction mapCacheClear() {\n  this.size = 0;\n  this.__data__ = {\n    \"hash\": new Hash_default(),\n    \"map\": new (Map_default || ListCache_default)(),\n    \"string\": new Hash_default()\n  };\n}\nvar mapCacheClear_default = mapCacheClear;\n\n// ../../node_modules/lodash-es/_isKeyable.js\nfunction isKeyable(value) {\n  var type = typeof value;\n  return type == \"string\" || type == \"number\" || type == \"symbol\" || type == \"boolean\" ? value !== \"__proto__\" : value === null;\n}\nvar isKeyable_default = isKeyable;\n\n// ../../node_modules/lodash-es/_getMapData.js\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable_default(key) ? data[typeof key == \"string\" ? \"string\" : \"hash\"] : data.map;\n}\nvar getMapData_default = getMapData;\n\n// ../../node_modules/lodash-es/_mapCacheDelete.js\nfunction mapCacheDelete(key) {\n  var result = getMapData_default(this, key)[\"delete\"](key);\n  this.size -= result ? 1 : 0;\n  return result;\n}\nvar mapCacheDelete_default = mapCacheDelete;\n\n// ../../node_modules/lodash-es/_mapCacheGet.js\nfunction mapCacheGet(key) {\n  return getMapData_default(this, key).get(key);\n}\nvar mapCacheGet_default = mapCacheGet;\n\n// ../../node_modules/lodash-es/_mapCacheHas.js\nfunction mapCacheHas(key) {\n  return getMapData_default(this, key).has(key);\n}\nvar mapCacheHas_default = mapCacheHas;\n\n// ../../node_modules/lodash-es/_mapCacheSet.js\nfunction mapCacheSet(key, value) {\n  var data = getMapData_default(this, key),\n    size = data.size;\n  data.set(key, value);\n  this.size += data.size == size ? 0 : 1;\n  return this;\n}\nvar mapCacheSet_default = mapCacheSet;\n\n// ../../node_modules/lodash-es/_MapCache.js\nfunction MapCache(entries) {\n  var index = -1,\n    length = entries == null ? 0 : entries.length;\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\nMapCache.prototype.clear = mapCacheClear_default;\nMapCache.prototype[\"delete\"] = mapCacheDelete_default;\nMapCache.prototype.get = mapCacheGet_default;\nMapCache.prototype.has = mapCacheHas_default;\nMapCache.prototype.set = mapCacheSet_default;\nvar MapCache_default = MapCache;\n\n// ../../node_modules/lodash-es/memoize.js\nvar FUNC_ERROR_TEXT = \"Expected a function\";\nfunction memoize(func, resolver) {\n  if (typeof func != \"function\" || resolver != null && typeof resolver != \"function\") {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var memoized = function () {\n    var args = arguments,\n      key = resolver ? resolver.apply(this, args) : args[0],\n      cache = memoized.cache;\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    var result = func.apply(this, args);\n    memoized.cache = cache.set(key, result) || cache;\n    return result;\n  };\n  memoized.cache = new (memoize.Cache || MapCache_default)();\n  return memoized;\n}\nmemoize.Cache = MapCache_default;\nvar memoize_default = memoize;\n\n// ../../node_modules/lodash-es/_memoizeCapped.js\nvar MAX_MEMOIZE_SIZE = 500;\nfunction memoizeCapped(func) {\n  var result = memoize_default(func, function (key) {\n    if (cache.size === MAX_MEMOIZE_SIZE) {\n      cache.clear();\n    }\n    return key;\n  });\n  var cache = result.cache;\n  return result;\n}\nvar memoizeCapped_default = memoizeCapped;\n\n// ../../node_modules/lodash-es/_stringToPath.js\nvar rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\nvar reEscapeChar = /\\\\(\\\\)?/g;\nvar stringToPath = memoizeCapped_default(function (string) {\n  var result = [];\n  if (string.charCodeAt(0) === 46) {\n    result.push(\"\");\n  }\n  string.replace(rePropName, function (match, number, quote, subString) {\n    result.push(quote ? subString.replace(reEscapeChar, \"$1\") : number || match);\n  });\n  return result;\n});\nvar stringToPath_default = stringToPath;\n\n// ../../node_modules/lodash-es/_arrayMap.js\nfunction arrayMap(array, iteratee) {\n  var index = -1,\n    length = array == null ? 0 : array.length,\n    result = Array(length);\n  while (++index < length) {\n    result[index] = iteratee(array[index], index, array);\n  }\n  return result;\n}\nvar arrayMap_default = arrayMap;\n\n// ../../node_modules/lodash-es/_baseToString.js\nvar INFINITY = 1 / 0;\nvar symbolProto = Symbol_default ? Symbol_default.prototype : void 0;\nvar symbolToString = symbolProto ? symbolProto.toString : void 0;\nfunction baseToString(value) {\n  if (typeof value == \"string\") {\n    return value;\n  }\n  if (isArray_default(value)) {\n    return arrayMap_default(value, baseToString) + \"\";\n  }\n  if (isSymbol_default(value)) {\n    return symbolToString ? symbolToString.call(value) : \"\";\n  }\n  var result = value + \"\";\n  return result == \"0\" && 1 / value == -INFINITY ? \"-0\" : result;\n}\nvar baseToString_default = baseToString;\n\n// ../../node_modules/lodash-es/toString.js\nfunction toString(value) {\n  return value == null ? \"\" : baseToString_default(value);\n}\nvar toString_default = toString;\n\n// ../../node_modules/lodash-es/_castPath.js\nfunction castPath(value, object) {\n  if (isArray_default(value)) {\n    return value;\n  }\n  return isKey_default(value, object) ? [value] : stringToPath_default(toString_default(value));\n}\nvar castPath_default = castPath;\n\n// ../../node_modules/lodash-es/_toKey.js\nvar INFINITY2 = 1 / 0;\nfunction toKey(value) {\n  if (typeof value == \"string\" || isSymbol_default(value)) {\n    return value;\n  }\n  var result = value + \"\";\n  return result == \"0\" && 1 / value == -INFINITY2 ? \"-0\" : result;\n}\nvar toKey_default = toKey;\n\n// ../../node_modules/lodash-es/_baseGet.js\nfunction baseGet(object, path) {\n  path = castPath_default(path, object);\n  var index = 0,\n    length = path.length;\n  while (object != null && index < length) {\n    object = object[toKey_default(path[index++])];\n  }\n  return index && index == length ? object : void 0;\n}\nvar baseGet_default = baseGet;\n\n// ../../node_modules/lodash-es/get.js\nfunction get(object, path, defaultValue) {\n  var result = object == null ? void 0 : baseGet_default(object, path);\n  return result === void 0 ? defaultValue : result;\n}\nvar get_default = get;\n\n// ../../node_modules/lodash-es/_overArg.js\nfunction overArg(func, transform) {\n  return function (arg) {\n    return func(transform(arg));\n  };\n}\nvar overArg_default = overArg;\n\n// ../../node_modules/lodash-es/_getPrototype.js\nvar getPrototype = overArg_default(Object.getPrototypeOf, Object);\nvar getPrototype_default = getPrototype;\n\n// ../../node_modules/lodash-es/isPlainObject.js\nvar objectTag = \"[object Object]\";\nvar funcProto3 = Function.prototype;\nvar objectProto6 = Object.prototype;\nvar funcToString3 = funcProto3.toString;\nvar hasOwnProperty5 = objectProto6.hasOwnProperty;\nvar objectCtorString = funcToString3.call(Object);\nfunction isPlainObject(value) {\n  if (!isObjectLike_default(value) || baseGetTag_default(value) != objectTag) {\n    return false;\n  }\n  var proto = getPrototype_default(value);\n  if (proto === null) {\n    return true;\n  }\n  var Ctor = hasOwnProperty5.call(proto, \"constructor\") && proto.constructor;\n  return typeof Ctor == \"function\" && Ctor instanceof Ctor && funcToString3.call(Ctor) == objectCtorString;\n}\nvar isPlainObject_default = isPlainObject;\n\n// ../../node_modules/lodash-es/last.js\nfunction last(array) {\n  var length = array == null ? 0 : array.length;\n  return length ? array[length - 1] : void 0;\n}\nvar last_default = last;\n\n// src/pointer.ts\nvar pointerMetaWeakMap = new WeakMap();\nvar cachedSubPathPointersWeakMap = new WeakMap();\nvar pointerMetaSymbol = Symbol(\"pointerMeta\");\nvar proxyHandler = {\n  get(pointerKey, prop) {\n    if (prop === pointerMetaSymbol) return pointerMetaWeakMap.get(pointerKey);\n    let subPathPointers = cachedSubPathPointersWeakMap.get(pointerKey);\n    if (!subPathPointers) {\n      subPathPointers = new Map();\n      cachedSubPathPointersWeakMap.set(pointerKey, subPathPointers);\n    }\n    const existing = subPathPointers.get(prop);\n    if (existing !== void 0) return existing;\n    const meta = pointerMetaWeakMap.get(pointerKey);\n    const subPointer = pointer({\n      root: meta.root,\n      path: [...meta.path, prop]\n    });\n    subPathPointers.set(prop, subPointer);\n    return subPointer;\n  }\n};\nvar getPointerMeta = p => {\n  const meta = p[pointerMetaSymbol];\n  return meta;\n};\nvar getPointerParts = p => {\n  const {\n    root: root2,\n    path\n  } = getPointerMeta(p);\n  return {\n    root: root2,\n    path\n  };\n};\nfunction pointer(args) {\n  var _a;\n  const meta = {\n    root: args.root,\n    path: (_a = args.path) != null ? _a : []\n  };\n  const pointerKey = {};\n  pointerMetaWeakMap.set(pointerKey, meta);\n  return new Proxy(pointerKey, proxyHandler);\n}\nvar pointer_default = pointer;\nvar isPointer = p => {\n  return p && !!getPointerMeta(p);\n};\n\n// src/utils/updateDeep.ts\nfunction updateDeep(state2, path, reducer) {\n  if (path.length === 0) return reducer(state2);\n  return hoop(state2, path, reducer);\n}\nvar hoop = (s, path, reducer) => {\n  if (path.length === 0) {\n    return reducer(s);\n  }\n  if (Array.isArray(s)) {\n    let [index, ...restOfPath] = path;\n    index = parseInt(String(index), 10);\n    if (isNaN(index)) index = 0;\n    const oldVal = s[index];\n    const newVal = hoop(oldVal, restOfPath, reducer);\n    if (oldVal === newVal) return s;\n    const newS = [...s];\n    newS.splice(index, 1, newVal);\n    return newS;\n  } else if (typeof s === \"object\" && s !== null) {\n    const [key, ...restOfPath] = path;\n    const oldVal = s[key];\n    const newVal = hoop(oldVal, restOfPath, reducer);\n    if (oldVal === newVal) return s;\n    const newS = __spreadProps(__spreadValues({}, s), {\n      [key]: newVal\n    });\n    return newS;\n  } else {\n    const [key, ...restOfPath] = path;\n    return {\n      [key]: hoop(void 0, restOfPath, reducer)\n    };\n  }\n};\n\n// src/utils/Stack.ts\nvar Stack = class {\n  constructor() {\n    this._head = void 0;\n  }\n  peek() {\n    return this._head && this._head.data;\n  }\n  pop() {\n    const head = this._head;\n    if (!head) {\n      return void 0;\n    }\n    this._head = head.next;\n    return head.data;\n  }\n  push(data) {\n    const node = {\n      next: this._head,\n      data\n    };\n    this._head = node;\n  }\n};\n\n// src/prism/Interface.ts\nfunction isPrism(d) {\n  return !!(d && d.isPrism && d.isPrism === true);\n}\n\n// src/prism/discoveryMechanism.ts\nfunction createMechanism() {\n  const noop = () => {};\n  const stack = new Stack();\n  const noopCollector = noop;\n  const pushCollector2 = collector => {\n    stack.push(collector);\n  };\n  const popCollector2 = collector => {\n    const existing = stack.peek();\n    if (existing !== collector) {\n      throw new Error(`Popped collector is not on top of the stack`);\n    }\n    stack.pop();\n  };\n  const startIgnoringDependencies2 = () => {\n    stack.push(noopCollector);\n  };\n  const stopIgnoringDependencies2 = () => {\n    if (stack.peek() !== noopCollector) {\n      if (process.env.NODE_ENV === \"development\") {\n        console.warn(\"This should never happen\");\n      }\n    } else {\n      stack.pop();\n    }\n  };\n  const reportResolutionStart2 = d => {\n    const possibleCollector = stack.peek();\n    if (possibleCollector) {\n      possibleCollector(d);\n    }\n    stack.push(noopCollector);\n  };\n  const reportResolutionEnd2 = _d => {\n    stack.pop();\n  };\n  return {\n    type: \"Dataverse_discoveryMechanism\",\n    startIgnoringDependencies: startIgnoringDependencies2,\n    stopIgnoringDependencies: stopIgnoringDependencies2,\n    reportResolutionStart: reportResolutionStart2,\n    reportResolutionEnd: reportResolutionEnd2,\n    pushCollector: pushCollector2,\n    popCollector: popCollector2\n  };\n}\nfunction getSharedMechanism() {\n  const varName = \"__dataverse_discoveryMechanism_sharedStack\";\n  const root2 = typeof window !== \"undefined\" ? window : typeof global !== \"undefined\" ? global : {};\n  if (root2) {\n    const existingMechanism = root2[varName];\n    if (existingMechanism && typeof existingMechanism === \"object\" && existingMechanism.type === \"Dataverse_discoveryMechanism\") {\n      return existingMechanism;\n    } else {\n      const mechanism = createMechanism();\n      root2[varName] = mechanism;\n      return mechanism;\n    }\n  } else {\n    return createMechanism();\n  }\n}\nvar {\n  startIgnoringDependencies,\n  stopIgnoringDependencies,\n  reportResolutionEnd,\n  reportResolutionStart,\n  pushCollector,\n  popCollector\n} = getSharedMechanism();\n\n// src/prism/prism.ts\nvar voidFn = () => {};\nvar HotHandle = class {\n  constructor(_fn, _prismInstance) {\n    this._fn = _fn;\n    this._prismInstance = _prismInstance;\n    this._didMarkDependentsAsStale = false;\n    this._isFresh = false;\n    this._cacheOfDendencyValues = new Map();\n    this._dependents = new Set();\n    this._dependencies = new Set();\n    this._possiblyStaleDeps = new Set();\n    this._scope = new HotScope(this);\n    this._lastValue = void 0;\n    this._forciblySetToStale = false;\n    this._reactToDependencyGoingStale = which => {\n      this._possiblyStaleDeps.add(which);\n      this._markAsStale();\n    };\n    for (const d of this._dependencies) {\n      d._addDependent(this._reactToDependencyGoingStale);\n    }\n    startIgnoringDependencies();\n    this.getValue();\n    stopIgnoringDependencies();\n  }\n  get hasDependents() {\n    return this._dependents.size > 0;\n  }\n  removeDependent(d) {\n    this._dependents.delete(d);\n  }\n  addDependent(d) {\n    this._dependents.add(d);\n  }\n  destroy() {\n    for (const d of this._dependencies) {\n      d._removeDependent(this._reactToDependencyGoingStale);\n    }\n    cleanupScopeStack(this._scope);\n  }\n  getValue() {\n    if (!this._isFresh) {\n      const newValue = this._recalculate();\n      this._lastValue = newValue;\n      this._isFresh = true;\n      this._didMarkDependentsAsStale = false;\n      this._forciblySetToStale = false;\n    }\n    return this._lastValue;\n  }\n  _recalculate() {\n    let value;\n    if (!this._forciblySetToStale) {\n      if (this._possiblyStaleDeps.size > 0) {\n        let anActuallyStaleDepWasFound = false;\n        startIgnoringDependencies();\n        for (const dep of this._possiblyStaleDeps) {\n          if (this._cacheOfDendencyValues.get(dep) !== dep.getValue()) {\n            anActuallyStaleDepWasFound = true;\n            break;\n          }\n        }\n        stopIgnoringDependencies();\n        this._possiblyStaleDeps.clear();\n        if (!anActuallyStaleDepWasFound) {\n          return this._lastValue;\n        }\n      }\n    }\n    const newDeps = new Set();\n    this._cacheOfDendencyValues.clear();\n    const collector = observedDep => {\n      newDeps.add(observedDep);\n      this._addDependency(observedDep);\n    };\n    pushCollector(collector);\n    hookScopeStack.push(this._scope);\n    try {\n      value = this._fn();\n    } catch (error) {\n      console.error(error);\n    } finally {\n      const topOfTheStack = hookScopeStack.pop();\n      if (topOfTheStack !== this._scope) {\n        console.warn(`The Prism hook stack has slipped. This is a bug.`);\n      }\n    }\n    popCollector(collector);\n    for (const dep of this._dependencies) {\n      if (!newDeps.has(dep)) {\n        this._removeDependency(dep);\n      }\n    }\n    this._dependencies = newDeps;\n    startIgnoringDependencies();\n    for (const dep of newDeps) {\n      this._cacheOfDendencyValues.set(dep, dep.getValue());\n    }\n    stopIgnoringDependencies();\n    return value;\n  }\n  forceStale() {\n    this._forciblySetToStale = true;\n    this._markAsStale();\n  }\n  _markAsStale() {\n    if (this._didMarkDependentsAsStale) return;\n    this._didMarkDependentsAsStale = true;\n    this._isFresh = false;\n    for (const dependent of this._dependents) {\n      dependent(this._prismInstance);\n    }\n  }\n  _addDependency(d) {\n    if (this._dependencies.has(d)) return;\n    this._dependencies.add(d);\n    d._addDependent(this._reactToDependencyGoingStale);\n  }\n  _removeDependency(d) {\n    if (!this._dependencies.has(d)) return;\n    this._dependencies.delete(d);\n    d._removeDependent(this._reactToDependencyGoingStale);\n  }\n};\nvar emptyObject = {};\nvar PrismInstance = class {\n  constructor(_fn) {\n    this._fn = _fn;\n    this.isPrism = true;\n    this._state = {\n      hot: false,\n      handle: void 0\n    };\n  }\n  get isHot() {\n    return this._state.hot;\n  }\n  onChange(ticker, listener) {\n    let immediate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    const dependent = () => {\n      ticker.onThisOrNextTick(refresh);\n    };\n    let lastValue = emptyObject;\n    const refresh = () => {\n      const newValue = this.getValue();\n      if (newValue === lastValue) return;\n      lastValue = newValue;\n      listener(newValue);\n    };\n    this._addDependent(dependent);\n    if (immediate) {\n      lastValue = this.getValue();\n      listener(lastValue);\n    }\n    const unsubscribe = () => {\n      this._removeDependent(dependent);\n      ticker.offThisOrNextTick(refresh);\n      ticker.offNextTick(refresh);\n    };\n    return unsubscribe;\n  }\n  onStale(callback) {\n    const untap = () => {\n      this._removeDependent(fn);\n    };\n    const fn = () => callback();\n    this._addDependent(fn);\n    return untap;\n  }\n  keepHot() {\n    return this.onStale(() => {});\n  }\n  _addDependent(d) {\n    if (!this._state.hot) {\n      this._goHot();\n    }\n    this._state.handle.addDependent(d);\n  }\n  _goHot() {\n    const hotHandle = new HotHandle(this._fn, this);\n    this._state = {\n      hot: true,\n      handle: hotHandle\n    };\n  }\n  _removeDependent(d) {\n    const state2 = this._state;\n    if (!state2.hot) {\n      return;\n    }\n    const handle = state2.handle;\n    handle.removeDependent(d);\n    if (!handle.hasDependents) {\n      this._state = {\n        hot: false,\n        handle: void 0\n      };\n      handle.destroy();\n    }\n  }\n  getValue() {\n    reportResolutionStart(this);\n    const state2 = this._state;\n    let val2;\n    if (state2.hot) {\n      val2 = state2.handle.getValue();\n    } else {\n      val2 = calculateColdPrism(this._fn);\n    }\n    reportResolutionEnd(this);\n    return val2;\n  }\n};\nvar HotScope = class {\n  constructor(_hotHandle) {\n    this._hotHandle = _hotHandle;\n    this._refs = new Map();\n    this.isPrismScope = true;\n    this.subs = {};\n    this.effects = new Map();\n    this.memos = new Map();\n  }\n  ref(key, initialValue) {\n    let ref2 = this._refs.get(key);\n    if (ref2 !== void 0) {\n      return ref2;\n    } else {\n      const ref3 = {\n        current: initialValue\n      };\n      this._refs.set(key, ref3);\n      return ref3;\n    }\n  }\n  effect(key, cb, deps) {\n    let effect2 = this.effects.get(key);\n    if (effect2 === void 0) {\n      effect2 = {\n        cleanup: voidFn,\n        deps: void 0\n      };\n      this.effects.set(key, effect2);\n    }\n    if (depsHaveChanged(effect2.deps, deps)) {\n      effect2.cleanup();\n      startIgnoringDependencies();\n      effect2.cleanup = safelyRun(cb, voidFn).value;\n      stopIgnoringDependencies();\n      effect2.deps = deps;\n    }\n  }\n  memo(key, fn, deps) {\n    let memo2 = this.memos.get(key);\n    if (memo2 === void 0) {\n      memo2 = {\n        cachedValue: null,\n        deps: void 0\n      };\n      this.memos.set(key, memo2);\n    }\n    if (depsHaveChanged(memo2.deps, deps)) {\n      startIgnoringDependencies();\n      memo2.cachedValue = safelyRun(fn, void 0).value;\n      stopIgnoringDependencies();\n      memo2.deps = deps;\n    }\n    return memo2.cachedValue;\n  }\n  state(key, initialValue) {\n    const {\n      value,\n      setValue\n    } = this.memo(\"state/\" + key, () => {\n      const value2 = {\n        current: initialValue\n      };\n      const setValue2 = newValue => {\n        value2.current = newValue;\n        this._hotHandle.forceStale();\n      };\n      return {\n        value: value2,\n        setValue: setValue2\n      };\n    }, []);\n    return [value.current, setValue];\n  }\n  sub(key) {\n    if (!this.subs[key]) {\n      this.subs[key] = new HotScope(this._hotHandle);\n    }\n    return this.subs[key];\n  }\n  cleanupEffects() {\n    for (const effect2 of this.effects.values()) {\n      safelyRun(effect2.cleanup, void 0);\n    }\n    this.effects.clear();\n  }\n  source(subscribe, getValue2) {\n    const sourceKey = \"$$source/blah\";\n    this.effect(sourceKey, () => {\n      const unsub = subscribe(() => {\n        this._hotHandle.forceStale();\n      });\n      return unsub;\n    }, [subscribe]);\n    return getValue2();\n  }\n};\nfunction cleanupScopeStack(scope2) {\n  for (const sub2 of Object.values(scope2.subs)) {\n    cleanupScopeStack(sub2);\n  }\n  scope2.cleanupEffects();\n}\nfunction safelyRun(fn, returnValueInCaseOfError) {\n  try {\n    return {\n      value: fn(),\n      ok: true\n    };\n  } catch (error) {\n    setTimeout(function PrismReportThrow() {\n      throw error;\n    });\n    return {\n      value: returnValueInCaseOfError,\n      ok: false\n    };\n  }\n}\nvar hookScopeStack = new Stack();\nfunction ref(key, initialValue) {\n  const scope2 = hookScopeStack.peek();\n  if (!scope2) {\n    throw new Error(`prism.ref() is called outside of a prism() call.`);\n  }\n  return scope2.ref(key, initialValue);\n}\nfunction effect(key, cb, deps) {\n  const scope2 = hookScopeStack.peek();\n  if (!scope2) {\n    throw new Error(`prism.effect() is called outside of a prism() call.`);\n  }\n  return scope2.effect(key, cb, deps);\n}\nfunction depsHaveChanged(oldDeps, newDeps) {\n  if (oldDeps === void 0 || newDeps === void 0) {\n    return true;\n  }\n  const len = oldDeps.length;\n  if (len !== newDeps.length) return true;\n  for (let i = 0; i < len; i++) {\n    if (oldDeps[i] !== newDeps[i]) return true;\n  }\n  return false;\n}\nfunction memo(key, fn, deps) {\n  const scope2 = hookScopeStack.peek();\n  if (!scope2) {\n    throw new Error(`prism.memo() is called outside of a prism() call.`);\n  }\n  return scope2.memo(key, fn, deps);\n}\nfunction state(key, initialValue) {\n  const scope2 = hookScopeStack.peek();\n  if (!scope2) {\n    throw new Error(`prism.state() is called outside of a prism() call.`);\n  }\n  return scope2.state(key, initialValue);\n}\nfunction ensurePrism() {\n  const scope2 = hookScopeStack.peek();\n  if (!scope2) {\n    throw new Error(`The parent function is called outside of a prism() call.`);\n  }\n}\nfunction scope(key, fn) {\n  const parentScope = hookScopeStack.peek();\n  if (!parentScope) {\n    throw new Error(`prism.scope() is called outside of a prism() call.`);\n  }\n  const subScope = parentScope.sub(key);\n  hookScopeStack.push(subScope);\n  const ret = safelyRun(fn, void 0).value;\n  hookScopeStack.pop();\n  return ret;\n}\nfunction sub(key, fn, deps) {\n  return memo(key, () => prism(fn), deps).getValue();\n}\nfunction inPrism() {\n  return !!hookScopeStack.peek();\n}\nfunction source(subscribe, getValue2) {\n  const scope2 = hookScopeStack.peek();\n  if (!scope2) {\n    throw new Error(`prism.source() is called outside of a prism() call.`);\n  }\n  return scope2.source(subscribe, getValue2);\n}\nvar prism = fn => {\n  return new PrismInstance(fn);\n};\nvar ColdScope = class {\n  effect(key, cb, deps) {\n    console.warn(`prism.effect() does not run in cold prisms`);\n  }\n  memo(key, fn, deps) {\n    return fn();\n  }\n  state(key, initialValue) {\n    return [initialValue, () => {}];\n  }\n  ref(key, initialValue) {\n    return {\n      current: initialValue\n    };\n  }\n  sub(key) {\n    return new ColdScope();\n  }\n  source(subscribe, getValue2) {\n    return getValue2();\n  }\n};\nfunction calculateColdPrism(fn) {\n  const scope2 = new ColdScope();\n  hookScopeStack.push(scope2);\n  let value;\n  try {\n    value = fn();\n  } catch (error) {\n    console.error(error);\n  } finally {\n    const topOfTheStack = hookScopeStack.pop();\n    if (topOfTheStack !== scope2) {\n      console.warn(`The Prism hook stack has slipped. This is a bug.`);\n    }\n  }\n  return value;\n}\nprism.ref = ref;\nprism.effect = effect;\nprism.memo = memo;\nprism.ensurePrism = ensurePrism;\nprism.state = state;\nprism.scope = scope;\nprism.sub = sub;\nprism.inPrism = inPrism;\nprism.source = source;\nvar prism_default = prism;\n\n// src/Atom.ts\nvar ValueTypes;\n(function (ValueTypes2) {\n  ValueTypes2[ValueTypes2[\"Dict\"] = 0] = \"Dict\";\n  ValueTypes2[ValueTypes2[\"Array\"] = 1] = \"Array\";\n  ValueTypes2[ValueTypes2[\"Other\"] = 2] = \"Other\";\n})(ValueTypes || (ValueTypes = {}));\nvar getTypeOfValue = v => {\n  if (Array.isArray(v)) return 1;\n  if (isPlainObject_default(v)) return 0;\n  return 2;\n};\nvar getKeyOfValue = function (v, key) {\n  let vType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : getTypeOfValue(v);\n  if (vType === 0 && typeof key === \"string\") {\n    return v[key];\n  } else if (vType === 1 && isValidArrayIndex(key)) {\n    return v[key];\n  } else {\n    return void 0;\n  }\n};\nvar isValidArrayIndex = key => {\n  const inNumber = typeof key === \"number\" ? key : parseInt(key, 10);\n  return !isNaN(inNumber) && inNumber >= 0 && inNumber < Infinity && (inNumber | 0) === inNumber;\n};\nvar Scope = class {\n  constructor(_parent, _path) {\n    this._parent = _parent;\n    this._path = _path;\n    this.children = new Map();\n    this.identityChangeListeners = new Set();\n  }\n  addIdentityChangeListener(cb) {\n    this.identityChangeListeners.add(cb);\n  }\n  removeIdentityChangeListener(cb) {\n    this.identityChangeListeners.delete(cb);\n    this._checkForGC();\n  }\n  removeChild(key) {\n    this.children.delete(key);\n    this._checkForGC();\n  }\n  getChild(key) {\n    return this.children.get(key);\n  }\n  getOrCreateChild(key) {\n    let child = this.children.get(key);\n    if (!child) {\n      child = child = new Scope(this, this._path.concat([key]));\n      this.children.set(key, child);\n    }\n    return child;\n  }\n  _checkForGC() {\n    if (this.identityChangeListeners.size > 0) return;\n    if (this.children.size > 0) return;\n    if (this._parent) {\n      this._parent.removeChild(last_default(this._path));\n    }\n  }\n};\nvar Atom = class {\n  constructor(initialState) {\n    this.$$isPointerToPrismProvider = true;\n    this.pointer = pointer_default({\n      root: this,\n      path: []\n    });\n    this.prism = this.pointerToPrism(this.pointer);\n    this._onPointerValueChange = (pointer2, cb) => {\n      const {\n        path\n      } = getPointerParts(pointer2);\n      const scope2 = this._getOrCreateScopeForPath(path);\n      scope2.identityChangeListeners.add(cb);\n      const unsubscribe = () => {\n        scope2.identityChangeListeners.delete(cb);\n      };\n      return unsubscribe;\n    };\n    this._currentState = initialState;\n    this._rootScope = new Scope(void 0, []);\n  }\n  set(newState) {\n    const oldState = this._currentState;\n    this._currentState = newState;\n    this._checkUpdates(this._rootScope, oldState, newState);\n  }\n  get() {\n    return this._currentState;\n  }\n  getByPointer(pointerOrFn) {\n    const pointer2 = isPointer(pointerOrFn) ? pointerOrFn : pointerOrFn(this.pointer);\n    const path = getPointerParts(pointer2).path;\n    return this._getIn(path);\n  }\n  _getIn(path) {\n    return path.length === 0 ? this.get() : get_default(this.get(), path);\n  }\n  reduce(fn) {\n    this.set(fn(this.get()));\n  }\n  reduceByPointer(pointerOrFn, reducer) {\n    const pointer2 = isPointer(pointerOrFn) ? pointerOrFn : pointerOrFn(this.pointer);\n    const path = getPointerParts(pointer2).path;\n    const newState = updateDeep(this.get(), path, reducer);\n    this.set(newState);\n  }\n  setByPointer(pointerOrFn, val2) {\n    this.reduceByPointer(pointerOrFn, () => val2);\n  }\n  _checkUpdates(scope2, oldState, newState) {\n    if (oldState === newState) return;\n    for (const cb of scope2.identityChangeListeners) {\n      cb(newState);\n    }\n    if (scope2.children.size === 0) return;\n    const oldValueType = getTypeOfValue(oldState);\n    const newValueType = getTypeOfValue(newState);\n    if (oldValueType === 2 && oldValueType === newValueType) return;\n    for (const [childKey, childScope] of scope2.children) {\n      const oldChildVal = getKeyOfValue(oldState, childKey, oldValueType);\n      const newChildVal = getKeyOfValue(newState, childKey, newValueType);\n      this._checkUpdates(childScope, oldChildVal, newChildVal);\n    }\n  }\n  _getOrCreateScopeForPath(path) {\n    let curScope = this._rootScope;\n    for (const pathEl of path) {\n      curScope = curScope.getOrCreateChild(pathEl);\n    }\n    return curScope;\n  }\n  pointerToPrism(pointer2) {\n    const {\n      path\n    } = getPointerParts(pointer2);\n    const subscribe = listener => this._onPointerValueChange(pointer2, listener);\n    const getValue2 = () => this._getIn(path);\n    return prism_default(() => {\n      return prism_default.source(subscribe, getValue2);\n    });\n  }\n};\n\n// src/pointerToPrism.ts\nvar identifyPrismWeakMap = new WeakMap();\nfunction isPointerToPrismProvider(val2) {\n  return typeof val2 === \"object\" && val2 !== null && val2[\"$$isPointerToPrismProvider\"] === true;\n}\nvar pointerToPrism = pointer2 => {\n  const meta = getPointerMeta(pointer2);\n  let prismInstance = identifyPrismWeakMap.get(meta);\n  if (!prismInstance) {\n    const root2 = meta.root;\n    if (!isPointerToPrismProvider(root2)) {\n      throw new Error(`Cannot run pointerToPrism() on a pointer whose root is not an PointerToPrismProvider`);\n    }\n    prismInstance = root2.pointerToPrism(pointer2);\n    identifyPrismWeakMap.set(meta, prismInstance);\n  }\n  return prismInstance;\n};\n\n// src/val.ts\nvar val = input => {\n  if (isPointer(input)) {\n    return pointerToPrism(input).getValue();\n  } else if (isPrism(input)) {\n    return input.getValue();\n  } else {\n    return input;\n  }\n};\n\n// src/prism/iterateAndCountTicks.ts\nfunction* iterateAndCountTicks(pointerOrPrism) {\n  let d;\n  if (isPointer(pointerOrPrism)) {\n    d = pointerToPrism(pointerOrPrism);\n  } else if (isPrism(pointerOrPrism)) {\n    d = pointerOrPrism;\n  } else {\n    throw new Error(`Only pointers and prisms are supported`);\n  }\n  let ticksCountedSinceLastYield = 0;\n  const untap = d.onStale(() => {\n    ticksCountedSinceLastYield++;\n  });\n  try {\n    while (true) {\n      const ticks = ticksCountedSinceLastYield;\n      ticksCountedSinceLastYield = 0;\n      yield {\n        value: d.getValue(),\n        ticks\n      };\n    }\n  } finally {\n    untap();\n  }\n}\n\n// src/Ticker.ts\nvar EMPTY_TICKS_BEFORE_GOING_DORMANT = 60 * 3;\nvar Ticker = class {\n  constructor(_conf) {\n    this._conf = _conf;\n    this._ticking = false;\n    this._dormant = true;\n    this._numberOfDormantTicks = 0;\n    this.__ticks = 0;\n    this._scheduledForThisOrNextTick = new Set();\n    this._scheduledForNextTick = new Set();\n    this._timeAtCurrentTick = 0;\n  }\n  get dormant() {\n    return this._dormant;\n  }\n  onThisOrNextTick(fn) {\n    this._scheduledForThisOrNextTick.add(fn);\n    if (this._dormant) {\n      this._goActive();\n    }\n  }\n  onNextTick(fn) {\n    this._scheduledForNextTick.add(fn);\n    if (this._dormant) {\n      this._goActive();\n    }\n  }\n  offThisOrNextTick(fn) {\n    this._scheduledForThisOrNextTick.delete(fn);\n  }\n  offNextTick(fn) {\n    this._scheduledForNextTick.delete(fn);\n  }\n  get time() {\n    if (this._ticking) {\n      return this._timeAtCurrentTick;\n    } else return performance.now();\n  }\n  _goActive() {\n    var _a, _b;\n    if (!this._dormant) return;\n    this._dormant = false;\n    (_b = (_a = this._conf) == null ? void 0 : _a.onActive) == null ? void 0 : _b.call(_a);\n  }\n  _goDormant() {\n    var _a, _b;\n    if (this._dormant) return;\n    this._dormant = true;\n    this._numberOfDormantTicks = 0;\n    (_b = (_a = this._conf) == null ? void 0 : _a.onDormant) == null ? void 0 : _b.call(_a);\n  }\n  tick() {\n    let t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : performance.now();\n    if (process.env.NODE_ENV === \"development\") {\n      if (!(this instanceof Ticker)) {\n        throw new Error('ticker.tick must be called while bound to the ticker. As in, \"ticker.tick(time)\" or \"requestAnimationFrame((t) => ticker.tick(t))\" for performance.');\n      }\n    }\n    this.__ticks++;\n    if (!this._dormant) {\n      if (this._scheduledForNextTick.size === 0 && this._scheduledForThisOrNextTick.size === 0) {\n        this._numberOfDormantTicks++;\n        if (this._numberOfDormantTicks >= EMPTY_TICKS_BEFORE_GOING_DORMANT) {\n          this._goDormant();\n          return;\n        }\n      }\n    }\n    this._ticking = true;\n    this._timeAtCurrentTick = t;\n    for (const v of this._scheduledForNextTick) {\n      this._scheduledForThisOrNextTick.add(v);\n    }\n    this._scheduledForNextTick.clear();\n    this._tick(0);\n    this._ticking = false;\n  }\n  _tick(iterationNumber) {\n    const time = this.time;\n    if (iterationNumber > 10) {\n      console.warn(\"_tick() recursing for 10 times\");\n    }\n    if (iterationNumber > 100) {\n      throw new Error(`Maximum recursion limit for _tick()`);\n    }\n    const oldSet = this._scheduledForThisOrNextTick;\n    this._scheduledForThisOrNextTick = new Set();\n    for (const fn of oldSet) {\n      fn(time);\n    }\n    if (this._scheduledForThisOrNextTick.size > 0) {\n      return this._tick(iterationNumber + 1);\n    }\n  }\n};\n\n// src/prism/iterateOver.ts\nfunction* iterateOver(pointerOrPrism) {\n  let d;\n  if (isPointer(pointerOrPrism)) {\n    d = pointerToPrism(pointerOrPrism);\n  } else if (isPrism(pointerOrPrism)) {\n    d = pointerOrPrism;\n  } else {\n    throw new Error(`Only pointers and prisms are supported`);\n  }\n  const ticker = new Ticker();\n  const untap = d.onChange(ticker, v => {});\n  try {\n    while (true) {\n      ticker.tick();\n      yield d.getValue();\n    }\n  } finally {\n    untap();\n  }\n}\n\n// src/PointerProxy.ts\nvar PointerProxy = class {\n  constructor(currentPointer) {\n    this.$$isPointerToPrismProvider = true;\n    this._currentPointerBox = new Atom(currentPointer);\n    this.pointer = pointer_default({\n      root: this,\n      path: []\n    });\n  }\n  setPointer(p) {\n    this._currentPointerBox.set(p);\n  }\n  pointerToPrism(pointer2) {\n    const {\n      path\n    } = getPointerMeta(pointer2);\n    return prism_default(() => {\n      const currentPointer = this._currentPointerBox.prism.getValue();\n      const subPointer = path.reduce((pointerSoFar, pathItem) => pointerSoFar[pathItem], currentPointer);\n      return val(subPointer);\n    });\n  }\n};","map":{"version":3,"sources":["../src/index.ts","../../../node_modules/lodash-es/isArray.js","../../../node_modules/lodash-es/_freeGlobal.js","../../../node_modules/lodash-es/_root.js","../../../node_modules/lodash-es/_Symbol.js","../../../node_modules/lodash-es/_getRawTag.js","../../../node_modules/lodash-es/_objectToString.js","../../../node_modules/lodash-es/_baseGetTag.js","../../../node_modules/lodash-es/isObjectLike.js","../../../node_modules/lodash-es/isSymbol.js","../../../node_modules/lodash-es/_isKey.js","../../../node_modules/lodash-es/isObject.js","../../../node_modules/lodash-es/isFunction.js","../../../node_modules/lodash-es/_coreJsData.js","../../../node_modules/lodash-es/_isMasked.js","../../../node_modules/lodash-es/_toSource.js","../../../node_modules/lodash-es/_baseIsNative.js","../../../node_modules/lodash-es/_getValue.js","../../../node_modules/lodash-es/_getNative.js","../../../node_modules/lodash-es/_nativeCreate.js","../../../node_modules/lodash-es/_hashClear.js","../../../node_modules/lodash-es/_hashDelete.js","../../../node_modules/lodash-es/_hashGet.js","../../../node_modules/lodash-es/_hashHas.js","../../../node_modules/lodash-es/_hashSet.js","../../../node_modules/lodash-es/_Hash.js","../../../node_modules/lodash-es/_listCacheClear.js","../../../node_modules/lodash-es/eq.js","../../../node_modules/lodash-es/_assocIndexOf.js","../../../node_modules/lodash-es/_listCacheDelete.js","../../../node_modules/lodash-es/_listCacheGet.js","../../../node_modules/lodash-es/_listCacheHas.js","../../../node_modules/lodash-es/_listCacheSet.js","../../../node_modules/lodash-es/_ListCache.js","../../../node_modules/lodash-es/_Map.js","../../../node_modules/lodash-es/_mapCacheClear.js","../../../node_modules/lodash-es/_isKeyable.js","../../../node_modules/lodash-es/_getMapData.js","../../../node_modules/lodash-es/_mapCacheDelete.js","../../../node_modules/lodash-es/_mapCacheGet.js","../../../node_modules/lodash-es/_mapCacheHas.js","../../../node_modules/lodash-es/_mapCacheSet.js","../../../node_modules/lodash-es/_MapCache.js","../../../node_modules/lodash-es/memoize.js","../../../node_modules/lodash-es/_memoizeCapped.js","../../../node_modules/lodash-es/_stringToPath.js","../../../node_modules/lodash-es/_arrayMap.js","../../../node_modules/lodash-es/_baseToString.js","../../../node_modules/lodash-es/toString.js","../../../node_modules/lodash-es/_castPath.js","../../../node_modules/lodash-es/_toKey.js","../../../node_modules/lodash-es/_baseGet.js","../../../node_modules/lodash-es/get.js","../../../node_modules/lodash-es/_overArg.js","../../../node_modules/lodash-es/_getPrototype.js","../../../node_modules/lodash-es/isPlainObject.js","../../../node_modules/lodash-es/last.js","../src/pointer.ts","../src/utils/updateDeep.ts","../src/utils/Stack.ts","../src/prism/Interface.ts","../src/prism/discoveryMechanism.ts","../src/prism/prism.ts","../src/Atom.ts","../src/pointerToPrism.ts","../src/val.ts","../src/prism/iterateAndCountTicks.ts","../src/Ticker.ts","../src/prism/iterateOver.ts","../src/PointerProxy.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * The animation-optimized FRP library powering the internals of Theatre.js.\n *\n * @packageDocumentation\n */\n\nexport type {PointerToPrismProvider} from './pointerToPrism'\nexport {default as Atom} from './Atom'\nexport {val} from './val'\nexport {pointerToPrism} from './pointerToPrism'\nexport {isPrism} from './prism/Interface'\nexport type {Prism} from './prism/Interface'\nexport {default as iterateAndCountTicks} from './prism/iterateAndCountTicks'\nexport {default as iterateOver} from './prism/iterateOver'\nexport {default as prism} from './prism/prism'\nexport {default as pointer, getPointerParts, isPointer} from './pointer'\nexport type {Pointer, PointerType, PointerMeta} from './pointer'\nexport {default as Ticker} from './Ticker'\nexport {default as PointerProxy} from './PointerProxy'\n","/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\nexport default isArray;\n","/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\nexport default freeGlobal;\n","import freeGlobal from './_freeGlobal.js';\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\nexport default root;\n","import root from './_root.js';\n\n/** Built-in value references. */\nvar Symbol = root.Symbol;\n\nexport default Symbol;\n","import Symbol from './_Symbol.js';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\nexport default getRawTag;\n","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\nexport default objectToString;\n","import Symbol from './_Symbol.js';\nimport getRawTag from './_getRawTag.js';\nimport objectToString from './_objectToString.js';\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\nexport default baseGetTag;\n","/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\nexport default isObjectLike;\n","import baseGetTag from './_baseGetTag.js';\nimport isObjectLike from './isObjectLike.js';\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && baseGetTag(value) == symbolTag);\n}\n\nexport default isSymbol;\n","import isArray from './isArray.js';\nimport isSymbol from './isSymbol.js';\n\n/** Used to match property names within property paths. */\nvar reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n    reIsPlainProp = /^\\w*$/;\n\n/**\n * Checks if `value` is a property name and not a property path.\n *\n * @private\n * @param {*} value The value to check.\n * @param {Object} [object] The object to query keys on.\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n */\nfunction isKey(value, object) {\n  if (isArray(value)) {\n    return false;\n  }\n  var type = typeof value;\n  if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n      value == null || isSymbol(value)) {\n    return true;\n  }\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n    (object != null && value in Object(object));\n}\n\nexport default isKey;\n","/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\nexport default isObject;\n","import baseGetTag from './_baseGetTag.js';\nimport isObject from './isObject.js';\n\n/** `Object#toString` result references. */\nvar asyncTag = '[object AsyncFunction]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    proxyTag = '[object Proxy]';\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\nexport default isFunction;\n","import root from './_root.js';\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\nexport default coreJsData;\n","import coreJsData from './_coreJsData.js';\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\nexport default isMasked;\n","/** Used for built-in method references. */\nvar funcProto = Function.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to convert.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\nexport default toSource;\n","import isFunction from './isFunction.js';\nimport isMasked from './_isMasked.js';\nimport isObject from './isObject.js';\nimport toSource from './_toSource.js';\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used for built-in method references. */\nvar funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\nexport default baseIsNative;\n","/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\nexport default getValue;\n","import baseIsNative from './_baseIsNative.js';\nimport getValue from './_getValue.js';\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\nexport default getNative;\n","import getNative from './_getNative.js';\n\n/* Built-in method references that are verified to be native. */\nvar nativeCreate = getNative(Object, 'create');\n\nexport default nativeCreate;\n","import nativeCreate from './_nativeCreate.js';\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n  this.size = 0;\n}\n\nexport default hashClear;\n","/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  var result = this.has(key) && delete this.__data__[key];\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\nexport default hashDelete;\n","import nativeCreate from './_nativeCreate.js';\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\nexport default hashGet;\n","import nativeCreate from './_nativeCreate.js';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);\n}\n\nexport default hashHas;\n","import nativeCreate from './_nativeCreate.js';\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  this.size += this.has(key) ? 0 : 1;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\nexport default hashSet;\n","import hashClear from './_hashClear.js';\nimport hashDelete from './_hashDelete.js';\nimport hashGet from './_hashGet.js';\nimport hashHas from './_hashHas.js';\nimport hashSet from './_hashSet.js';\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\nexport default Hash;\n","/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n  this.size = 0;\n}\n\nexport default listCacheClear;\n","/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\nexport default eq;\n","import eq from './eq.js';\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\nexport default assocIndexOf;\n","import assocIndexOf from './_assocIndexOf.js';\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype;\n\n/** Built-in value references. */\nvar splice = arrayProto.splice;\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  --this.size;\n  return true;\n}\n\nexport default listCacheDelete;\n","import assocIndexOf from './_assocIndexOf.js';\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\nexport default listCacheGet;\n","import assocIndexOf from './_assocIndexOf.js';\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\nexport default listCacheHas;\n","import assocIndexOf from './_assocIndexOf.js';\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    ++this.size;\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\nexport default listCacheSet;\n","import listCacheClear from './_listCacheClear.js';\nimport listCacheDelete from './_listCacheDelete.js';\nimport listCacheGet from './_listCacheGet.js';\nimport listCacheHas from './_listCacheHas.js';\nimport listCacheSet from './_listCacheSet.js';\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\nexport default ListCache;\n","import getNative from './_getNative.js';\nimport root from './_root.js';\n\n/* Built-in method references that are verified to be native. */\nvar Map = getNative(root, 'Map');\n\nexport default Map;\n","import Hash from './_Hash.js';\nimport ListCache from './_ListCache.js';\nimport Map from './_Map.js';\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.size = 0;\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\nexport default mapCacheClear;\n","/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\nexport default isKeyable;\n","import isKeyable from './_isKeyable.js';\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\nexport default getMapData;\n","import getMapData from './_getMapData.js';\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  var result = getMapData(this, key)['delete'](key);\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\nexport default mapCacheDelete;\n","import getMapData from './_getMapData.js';\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\nexport default mapCacheGet;\n","import getMapData from './_getMapData.js';\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\nexport default mapCacheHas;\n","import getMapData from './_getMapData.js';\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  var data = getMapData(this, key),\n      size = data.size;\n\n  data.set(key, value);\n  this.size += data.size == size ? 0 : 1;\n  return this;\n}\n\nexport default mapCacheSet;\n","import mapCacheClear from './_mapCacheClear.js';\nimport mapCacheDelete from './_mapCacheDelete.js';\nimport mapCacheGet from './_mapCacheGet.js';\nimport mapCacheHas from './_mapCacheHas.js';\nimport mapCacheSet from './_mapCacheSet.js';\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\nexport default MapCache;\n","import MapCache from './_MapCache.js';\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `clear`, `delete`, `get`, `has`, and `set`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to have its output memoized.\n * @param {Function} [resolver] The function to resolve the cache key.\n * @returns {Function} Returns the new memoized function.\n * @example\n *\n * var object = { 'a': 1, 'b': 2 };\n * var other = { 'c': 3, 'd': 4 };\n *\n * var values = _.memoize(_.values);\n * values(object);\n * // => [1, 2]\n *\n * values(other);\n * // => [3, 4]\n *\n * object.a = 2;\n * values(object);\n * // => [1, 2]\n *\n * // Modify the result cache.\n * values.cache.set(object, ['a', 'b']);\n * values(object);\n * // => ['a', 'b']\n *\n * // Replace `_.memoize.Cache`.\n * _.memoize.Cache = WeakMap;\n */\nfunction memoize(func, resolver) {\n  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var memoized = function() {\n    var args = arguments,\n        key = resolver ? resolver.apply(this, args) : args[0],\n        cache = memoized.cache;\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    var result = func.apply(this, args);\n    memoized.cache = cache.set(key, result) || cache;\n    return result;\n  };\n  memoized.cache = new (memoize.Cache || MapCache);\n  return memoized;\n}\n\n// Expose `MapCache`.\nmemoize.Cache = MapCache;\n\nexport default memoize;\n","import memoize from './memoize.js';\n\n/** Used as the maximum memoize cache size. */\nvar MAX_MEMOIZE_SIZE = 500;\n\n/**\n * A specialized version of `_.memoize` which clears the memoized function's\n * cache when it exceeds `MAX_MEMOIZE_SIZE`.\n *\n * @private\n * @param {Function} func The function to have its output memoized.\n * @returns {Function} Returns the new memoized function.\n */\nfunction memoizeCapped(func) {\n  var result = memoize(func, function(key) {\n    if (cache.size === MAX_MEMOIZE_SIZE) {\n      cache.clear();\n    }\n    return key;\n  });\n\n  var cache = result.cache;\n  return result;\n}\n\nexport default memoizeCapped;\n","import memoizeCapped from './_memoizeCapped.js';\n\n/** Used to match property names within property paths. */\nvar rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n/** Used to match backslashes in property paths. */\nvar reEscapeChar = /\\\\(\\\\)?/g;\n\n/**\n * Converts `string` to a property path array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the property path array.\n */\nvar stringToPath = memoizeCapped(function(string) {\n  var result = [];\n  if (string.charCodeAt(0) === 46 /* . */) {\n    result.push('');\n  }\n  string.replace(rePropName, function(match, number, quote, subString) {\n    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));\n  });\n  return result;\n});\n\nexport default stringToPath;\n","/**\n * A specialized version of `_.map` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction arrayMap(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      result = Array(length);\n\n  while (++index < length) {\n    result[index] = iteratee(array[index], index, array);\n  }\n  return result;\n}\n\nexport default arrayMap;\n","import Symbol from './_Symbol.js';\nimport arrayMap from './_arrayMap.js';\nimport isArray from './isArray.js';\nimport isSymbol from './isSymbol.js';\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isArray(value)) {\n    // Recursively convert values (susceptible to call stack limits).\n    return arrayMap(value, baseToString) + '';\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\nexport default baseToString;\n","import baseToString from './_baseToString.js';\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\nexport default toString;\n","import isArray from './isArray.js';\nimport isKey from './_isKey.js';\nimport stringToPath from './_stringToPath.js';\nimport toString from './toString.js';\n\n/**\n * Casts `value` to a path array if it's not one.\n *\n * @private\n * @param {*} value The value to inspect.\n * @param {Object} [object] The object to query keys on.\n * @returns {Array} Returns the cast property path array.\n */\nfunction castPath(value, object) {\n  if (isArray(value)) {\n    return value;\n  }\n  return isKey(value, object) ? [value] : stringToPath(toString(value));\n}\n\nexport default castPath;\n","import isSymbol from './isSymbol.js';\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/**\n * Converts `value` to a string key if it's not a string or symbol.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {string|symbol} Returns the key.\n */\nfunction toKey(value) {\n  if (typeof value == 'string' || isSymbol(value)) {\n    return value;\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\nexport default toKey;\n","import castPath from './_castPath.js';\nimport toKey from './_toKey.js';\n\n/**\n * The base implementation of `_.get` without support for default values.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @returns {*} Returns the resolved value.\n */\nfunction baseGet(object, path) {\n  path = castPath(path, object);\n\n  var index = 0,\n      length = path.length;\n\n  while (object != null && index < length) {\n    object = object[toKey(path[index++])];\n  }\n  return (index && index == length) ? object : undefined;\n}\n\nexport default baseGet;\n","import baseGet from './_baseGet.js';\n\n/**\n * Gets the value at `path` of `object`. If the resolved value is\n * `undefined`, the `defaultValue` is returned in its place.\n *\n * @static\n * @memberOf _\n * @since 3.7.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n * @returns {*} Returns the resolved value.\n * @example\n *\n * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n *\n * _.get(object, 'a[0].b.c');\n * // => 3\n *\n * _.get(object, ['a', '0', 'b', 'c']);\n * // => 3\n *\n * _.get(object, 'a.b.c', 'default');\n * // => 'default'\n */\nfunction get(object, path, defaultValue) {\n  var result = object == null ? undefined : baseGet(object, path);\n  return result === undefined ? defaultValue : result;\n}\n\nexport default get;\n","/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\nexport default overArg;\n","import overArg from './_overArg.js';\n\n/** Built-in value references. */\nvar getPrototype = overArg(Object.getPrototypeOf, Object);\n\nexport default getPrototype;\n","import baseGetTag from './_baseGetTag.js';\nimport getPrototype from './_getPrototype.js';\nimport isObjectLike from './isObjectLike.js';\n\n/** `Object#toString` result references. */\nvar objectTag = '[object Object]';\n\n/** Used for built-in method references. */\nvar funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to infer the `Object` constructor. */\nvar objectCtorString = funcToString.call(Object);\n\n/**\n * Checks if `value` is a plain object, that is, an object created by the\n * `Object` constructor or one with a `[[Prototype]]` of `null`.\n *\n * @static\n * @memberOf _\n * @since 0.8.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n * }\n *\n * _.isPlainObject(new Foo);\n * // => false\n *\n * _.isPlainObject([1, 2, 3]);\n * // => false\n *\n * _.isPlainObject({ 'x': 0, 'y': 0 });\n * // => true\n *\n * _.isPlainObject(Object.create(null));\n * // => true\n */\nfunction isPlainObject(value) {\n  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {\n    return false;\n  }\n  var proto = getPrototype(value);\n  if (proto === null) {\n    return true;\n  }\n  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;\n  return typeof Ctor == 'function' && Ctor instanceof Ctor &&\n    funcToString.call(Ctor) == objectCtorString;\n}\n\nexport default isPlainObject;\n","/**\n * Gets the last element of `array`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The array to query.\n * @returns {*} Returns the last element of `array`.\n * @example\n *\n * _.last([1, 2, 3]);\n * // => 3\n */\nfunction last(array) {\n  var length = array == null ? 0 : array.length;\n  return length ? array[length - 1] : undefined;\n}\n\nexport default last;\n","import type {$IntentionalAny} from './types'\n\ntype PathToProp = Array<string | number>\n\nexport type PointerMeta = {\n  root: {}\n  path: (string | number)[]\n}\n\n/** We are using an empty object as a WeakMap key for storing pointer meta data */\ntype WeakPointerKey = {}\n\nexport type UnindexableTypesForPointer =\n  | number\n  | string\n  | boolean\n  | null\n  | void\n  | undefined\n  | Function // eslint-disable-line @typescript-eslint/ban-types\n\nexport type UnindexablePointer = {\n  [K in $IntentionalAny]: Pointer<undefined>\n}\n\nconst pointerMetaWeakMap = new WeakMap<WeakPointerKey, PointerMeta>()\nconst cachedSubPathPointersWeakMap = new WeakMap<\n  WeakPointerKey,\n  Map<string | number, Pointer<unknown>>\n>()\n\n/**\n * A wrapper type for the type a `Pointer` points to.\n */\nexport type PointerType<O> = {\n  /**\n   * Only accessible via the type system.\n   * This is a helper for getting the underlying pointer type\n   * via the type space.\n   */\n  $$__pointer_type: O\n}\n\n/**\n * The type of {@link Atom} pointers. See {@link pointer|pointer()} for an\n * explanation of pointers.\n *\n * @see Atom\n *\n * @remarks\n * The Pointer type is quite tricky because it doesn't play well with `any` and other inexact types.\n * Here is an example that one would expect to work, but currently doesn't:\n * ```ts\n * declare function expectAnyPointer(pointer: Pointer<any>): void\n *\n * expectAnyPointer(null as Pointer<{}>) // this shows as a type error because Pointer<{}> is not assignable to Pointer<any>, even though it should\n * ```\n *\n * The current solution is to just avoid using `any` with pointer-related code (or type-test it well).\n * But if you enjoy solving typescript puzzles, consider fixing this :)\n * Potentially, [TypeScript variance annotations in 4.7+](https://devblogs.microsoft.com/typescript/announcing-typescript-4-7-beta/#optional-variance-annotations-for-type-parameters)\n * might be able to help us.\n */\nexport type Pointer<O> = PointerType<O> &\n  // `Exclude<O, undefined>` will remove `undefined` from the first type\n  // `undefined extends O ? undefined : never` will give us `undefined` if `O` is `... | undefined`\n  PointerInner<Exclude<O, undefined>, undefined extends O ? undefined : never>\n\n// By separating the `O` (non-undefined) from the `undefined` or `never`, we\n// can properly use `O extends ...` to determine the kind of potential value\n// without actually discarding optionality information.\ntype PointerInner<O, Optional> = O extends UnindexableTypesForPointer\n  ? UnindexablePointer\n  : unknown extends O\n  ? UnindexablePointer\n  : O extends (infer T)[]\n  ? Pointer<T>[]\n  : O extends {}\n  ? {\n      [K in keyof O]-?: Pointer<O[K] | Optional>\n    }\n  : UnindexablePointer\n\nconst pointerMetaSymbol = Symbol('pointerMeta')\n\nconst proxyHandler = {\n  get(\n    pointerKey: WeakPointerKey,\n    prop: string | typeof pointerMetaSymbol,\n  ): $IntentionalAny {\n    if (prop === pointerMetaSymbol) return pointerMetaWeakMap.get(pointerKey)!\n\n    let subPathPointers = cachedSubPathPointersWeakMap.get(pointerKey)\n    if (!subPathPointers) {\n      subPathPointers = new Map()\n      cachedSubPathPointersWeakMap.set(pointerKey, subPathPointers)\n    }\n\n    const existing = subPathPointers.get(prop)\n    if (existing !== undefined) return existing\n\n    const meta = pointerMetaWeakMap.get(pointerKey)!\n\n    const subPointer = pointer({root: meta.root, path: [...meta.path, prop]})\n    subPathPointers.set(prop, subPointer)\n    return subPointer\n  },\n}\n\n/**\n * Returns the metadata associated with the pointer. Usually the root object and\n * the path.\n *\n * @param p - The pointer.\n */\nexport const getPointerMeta = <_>(p: PointerType<_>): PointerMeta => {\n  // @ts-ignore @todo\n  const meta: PointerMeta = p[\n    pointerMetaSymbol as unknown as $IntentionalAny\n  ] as $IntentionalAny\n  return meta\n}\n\n/**\n * Returns the root object and the path of the pointer.\n *\n * @example\n * ```ts\n * const {root, path} = getPointerParts(pointer)\n * ```\n *\n * @param p - The pointer.\n *\n * @returns An object with two properties: `root`-the root object or the pointer, and `path`-the path of the pointer. `path` is an array of the property-chain.\n */\nexport const getPointerParts = <_>(\n  p: Pointer<_>,\n): {root: {}; path: PathToProp} => {\n  const {root, path} = getPointerMeta(p)\n  return {root, path}\n}\n\n/**\n * Creates a pointer to a (nested) property of an {@link Atom}.\n *\n * @remarks\n * Pointers are used to make prisms of properties or nested properties of\n * {@link Atom|Atoms}.\n *\n * Pointers also allow easy construction of new pointers pointing to nested members\n * of the root object, by simply using property chaining. E.g. `somePointer.a.b` will\n * create a new pointer that has `'a'` and `'b'` added to the path of `somePointer`.\n *\n * @example\n * ```ts\n * // Here, sum is a prism that updates whenever the a or b prop of someAtom does.\n * const sum = prism(() => {\n *   return val(pointer({root: someAtom, path: ['a']})) + val(pointer({root: someAtom, path: ['b']}));\n * });\n *\n * // Note, atoms have a convenience Atom.pointer property that points to the root,\n * // which you would normally use in this situation.\n * const sum = prism(() => {\n *   return val(someAtom.pointer.a) + val(someAtom.pointer.b);\n * });\n * ```\n *\n * @param args - The pointer parameters.\n *\n * @typeParam O - The type of the value being pointed to.\n */\nfunction pointer<O>(args: {root: {}; path?: Array<string | number>}) {\n  const meta: PointerMeta = {\n    root: args.root as $IntentionalAny,\n    path: args.path ?? [],\n  }\n  const pointerKey: WeakPointerKey = {}\n  pointerMetaWeakMap.set(pointerKey, meta)\n  return new Proxy(pointerKey, proxyHandler) as Pointer<O>\n}\n\nexport default pointer\n\n/**\n * Returns whether `p` is a pointer.\n */\nexport const isPointer = (p: $IntentionalAny): p is Pointer<unknown> => {\n  return p && !!getPointerMeta(p)\n}\n","import type {$FixMe, $IntentionalAny} from '../types'\n\nexport default function updateDeep<S>(\n  state: S,\n  path: (string | number | undefined)[],\n  reducer: (...args: $IntentionalAny[]) => $IntentionalAny,\n): S {\n  if (path.length === 0) return reducer(state)\n  return hoop(state, path as $IntentionalAny, reducer)\n}\n\nconst hoop = (\n  s: $FixMe,\n  path: (string | number)[],\n  reducer: $FixMe,\n): $FixMe => {\n  if (path.length === 0) {\n    return reducer(s)\n  }\n  if (Array.isArray(s)) {\n    let [index, ...restOfPath] = path\n    index = parseInt(String(index), 10)\n    if (isNaN(index)) index = 0\n    const oldVal = s[index]\n    const newVal = hoop(oldVal, restOfPath, reducer)\n    if (oldVal === newVal) return s\n    const newS = [...s]\n    newS.splice(index, 1, newVal)\n    return newS\n  } else if (typeof s === 'object' && s !== null) {\n    const [key, ...restOfPath] = path\n    const oldVal = s[key]\n    const newVal = hoop(oldVal, restOfPath, reducer)\n    if (oldVal === newVal) return s\n    const newS = {...s, [key]: newVal}\n    return newS\n  } else {\n    const [key, ...restOfPath] = path\n\n    return {[key]: hoop(undefined, restOfPath, reducer)}\n  }\n}\n","interface Node<Data> {\n  next: undefined | Node<Data>\n  data: Data\n}\n\n/**\n * Just a simple LinkedList\n */\nexport default class Stack<Data> {\n  _head: undefined | Node<Data>\n\n  constructor() {\n    this._head = undefined\n  }\n\n  peek() {\n    return this._head && this._head.data\n  }\n\n  pop() {\n    const head = this._head\n    if (!head) {\n      return undefined\n    }\n    this._head = head.next\n    return head.data\n  }\n\n  push(data: Data) {\n    const node = {next: this._head, data}\n    this._head = node\n  }\n}\n","import type Ticker from '../Ticker'\nimport type {$IntentionalAny, VoidFn} from '../types'\n\ntype IDependent = (msgComingFrom: Prism<$IntentionalAny>) => void\n\n/**\n * Common interface for prisms.\n */\nexport interface Prism<V> {\n  /**\n   * Whether the object is a prism.\n   */\n  isPrism: true\n\n  /**\n   * Whether the prism is hot.\n   */\n  isHot: boolean\n\n  /**\n   * Calls `listener` with a fresh value every time the prism _has_ a new value, throttled by Ticker.\n   */\n  onChange(\n    ticker: Ticker,\n    listener: (v: V) => void,\n    immediate?: boolean,\n  ): VoidFn\n\n  onStale(cb: () => void): VoidFn\n\n  /**\n   * Keep the prism hot, even if there are no tappers (subscribers).\n   */\n  keepHot(): VoidFn\n\n  /**\n   * Add a prism as a dependent of this prism.\n   *\n   * @param d - The prism to be made a dependent of this prism.\n   *\n   * @see _removeDependent\n   *\n   * @internal\n   */\n  _addDependent(d: IDependent): void\n\n  /**\n   * Remove a prism as a dependent of this prism.\n   *\n   * @param d - The prism to be removed from as a dependent of this prism.\n   *\n   * @see _addDependent\n   * @internal\n   */\n  _removeDependent(d: IDependent): void\n\n  /**\n   * Gets the current value of the prism. If the value is stale, it causes the prism to freshen.\n   */\n  getValue(): V\n}\n\n/**\n * Returns whether `d` is a prism.\n */\nexport function isPrism(d: any): d is Prism<unknown> {\n  return !!(d && d.isPrism && d.isPrism === true)\n}\n","import type {$IntentionalAny} from '../types'\nimport Stack from '../utils/Stack'\nimport type {Prism} from './Interface'\n\nfunction createMechanism() {\n  const noop = () => {}\n\n  const stack = new Stack<Collector>()\n  const noopCollector: Collector = noop\n\n  type Collector = (d: Prism<$IntentionalAny>) => void\n\n  const pushCollector = (collector: Collector): void => {\n    stack.push(collector)\n  }\n\n  const popCollector = (collector: Collector): void => {\n    const existing = stack.peek()\n    if (existing !== collector) {\n      throw new Error(`Popped collector is not on top of the stack`)\n    }\n    stack.pop()\n  }\n\n  const startIgnoringDependencies = () => {\n    stack.push(noopCollector)\n  }\n\n  const stopIgnoringDependencies = () => {\n    if (stack.peek() !== noopCollector) {\n      if (process.env.NODE_ENV === 'development') {\n        console.warn('This should never happen')\n      }\n    } else {\n      stack.pop()\n    }\n  }\n\n  const reportResolutionStart = (d: Prism<$IntentionalAny>) => {\n    const possibleCollector = stack.peek()\n    if (possibleCollector) {\n      possibleCollector(d)\n    }\n\n    stack.push(noopCollector)\n  }\n\n  const reportResolutionEnd = (_d: Prism<$IntentionalAny>) => {\n    stack.pop()\n  }\n\n  return {\n    type: 'Dataverse_discoveryMechanism' as 'Dataverse_discoveryMechanism',\n    startIgnoringDependencies,\n    stopIgnoringDependencies,\n    reportResolutionStart,\n    reportResolutionEnd,\n    pushCollector,\n    popCollector,\n  }\n}\n\nfunction getSharedMechanism(): ReturnType<typeof createMechanism> {\n  const varName = '__dataverse_discoveryMechanism_sharedStack'\n  const root =\n    typeof window !== 'undefined'\n      ? window\n      : typeof global !== 'undefined'\n      ? global\n      : {}\n  if (root) {\n    const existingMechanism: ReturnType<typeof createMechanism> | undefined =\n      // @ts-ignore ignore\n      root[varName]\n    if (\n      existingMechanism &&\n      typeof existingMechanism === 'object' &&\n      existingMechanism.type === 'Dataverse_discoveryMechanism'\n    ) {\n      return existingMechanism\n    } else {\n      const mechanism = createMechanism()\n      // @ts-ignore ignore\n      root[varName] = mechanism\n      return mechanism\n    }\n  } else {\n    return createMechanism()\n  }\n}\n\nexport const {\n  startIgnoringDependencies,\n  stopIgnoringDependencies,\n  reportResolutionEnd,\n  reportResolutionStart,\n  pushCollector,\n  popCollector,\n} = getSharedMechanism()\n","import type Ticker from '../Ticker'\nimport type {$IntentionalAny, VoidFn} from '../types'\nimport Stack from '../utils/Stack'\nimport type {Prism} from './Interface'\nimport {isPrism} from './Interface'\nimport {\n  startIgnoringDependencies,\n  stopIgnoringDependencies,\n  pushCollector,\n  popCollector,\n  reportResolutionStart,\n  reportResolutionEnd,\n} from './discoveryMechanism'\n\ntype IDependent = (msgComingFrom: Prism<$IntentionalAny>) => void\n\nconst voidFn = () => {}\n\nclass HotHandle<V> {\n  private _didMarkDependentsAsStale: boolean = false\n  private _isFresh: boolean = false\n  protected _cacheOfDendencyValues: Map<Prism<unknown>, unknown> = new Map()\n\n  /**\n   * @internal\n   */\n  protected _dependents: Set<IDependent> = new Set()\n\n  /**\n   * @internal\n   */\n  protected _dependencies: Set<Prism<$IntentionalAny>> = new Set()\n\n  protected _possiblyStaleDeps = new Set<Prism<unknown>>()\n\n  private _scope: HotScope = new HotScope(\n    this as $IntentionalAny as HotHandle<unknown>,\n  )\n\n  /**\n   * @internal\n   */\n  protected _lastValue: undefined | V = undefined\n\n  /**\n   * If true, the prism is stale even though its dependencies aren't\n   * marked as such. This is used by `prism.source()` and `prism.state()`\n   * to mark the prism as stale.\n   */\n  private _forciblySetToStale: boolean = false\n\n  constructor(\n    private readonly _fn: () => V,\n    private readonly _prismInstance: PrismInstance<V>,\n  ) {\n    for (const d of this._dependencies) {\n      d._addDependent(this._reactToDependencyGoingStale)\n    }\n\n    startIgnoringDependencies()\n    this.getValue()\n    stopIgnoringDependencies()\n  }\n\n  get hasDependents(): boolean {\n    return this._dependents.size > 0\n  }\n  removeDependent(d: IDependent) {\n    this._dependents.delete(d)\n  }\n  addDependent(d: IDependent) {\n    this._dependents.add(d)\n  }\n\n  destroy() {\n    for (const d of this._dependencies) {\n      d._removeDependent(this._reactToDependencyGoingStale)\n    }\n    cleanupScopeStack(this._scope)\n  }\n\n  getValue(): V {\n    if (!this._isFresh) {\n      const newValue = this._recalculate()\n      this._lastValue = newValue\n      this._isFresh = true\n      this._didMarkDependentsAsStale = false\n      this._forciblySetToStale = false\n    }\n    return this._lastValue!\n  }\n\n  _recalculate() {\n    let value: V\n\n    if (!this._forciblySetToStale) {\n      if (this._possiblyStaleDeps.size > 0) {\n        let anActuallyStaleDepWasFound = false\n        startIgnoringDependencies()\n        for (const dep of this._possiblyStaleDeps) {\n          if (this._cacheOfDendencyValues.get(dep) !== dep.getValue()) {\n            anActuallyStaleDepWasFound = true\n            break\n          }\n        }\n        stopIgnoringDependencies()\n        this._possiblyStaleDeps.clear()\n        if (!anActuallyStaleDepWasFound) {\n          return this._lastValue!\n        }\n      }\n    }\n\n    const newDeps: Set<Prism<unknown>> = new Set()\n    this._cacheOfDendencyValues.clear()\n\n    const collector = (observedDep: Prism<unknown>): void => {\n      newDeps.add(observedDep)\n      this._addDependency(observedDep)\n    }\n\n    pushCollector(collector)\n\n    hookScopeStack.push(this._scope)\n    try {\n      value = this._fn()\n    } catch (error) {\n      console.error(error)\n    } finally {\n      const topOfTheStack = hookScopeStack.pop()\n      if (topOfTheStack !== this._scope) {\n        console.warn(\n          // @todo guide the user to report the bug in an issue\n          `The Prism hook stack has slipped. This is a bug.`,\n        )\n      }\n    }\n\n    popCollector(collector)\n\n    for (const dep of this._dependencies) {\n      if (!newDeps.has(dep)) {\n        this._removeDependency(dep)\n      }\n    }\n\n    this._dependencies = newDeps\n\n    startIgnoringDependencies()\n    for (const dep of newDeps) {\n      this._cacheOfDendencyValues.set(dep, dep.getValue())\n    }\n    stopIgnoringDependencies()\n\n    return value!\n  }\n\n  forceStale() {\n    this._forciblySetToStale = true\n    this._markAsStale()\n  }\n\n  protected _reactToDependencyGoingStale = (which: Prism<$IntentionalAny>) => {\n    this._possiblyStaleDeps.add(which)\n\n    this._markAsStale()\n  }\n\n  private _markAsStale() {\n    if (this._didMarkDependentsAsStale) return\n\n    this._didMarkDependentsAsStale = true\n    this._isFresh = false\n\n    for (const dependent of this._dependents) {\n      dependent(this._prismInstance)\n    }\n  }\n\n  /**\n   * @internal\n   */\n  protected _addDependency(d: Prism<$IntentionalAny>) {\n    if (this._dependencies.has(d)) return\n    this._dependencies.add(d)\n    d._addDependent(this._reactToDependencyGoingStale)\n  }\n\n  /**\n   * @internal\n   */\n  protected _removeDependency(d: Prism<$IntentionalAny>) {\n    if (!this._dependencies.has(d)) return\n    this._dependencies.delete(d)\n    d._removeDependent(this._reactToDependencyGoingStale)\n  }\n}\n\nconst emptyObject = {}\n\nclass PrismInstance<V> implements Prism<V> {\n  /**\n   * Whether the object is a prism.\n   */\n  readonly isPrism: true = true\n\n  private _state:\n    | {hot: false; handle: undefined}\n    | {hot: true; handle: HotHandle<V>} = {\n    hot: false,\n    handle: undefined,\n  }\n\n  constructor(private readonly _fn: () => V) {}\n\n  /**\n   * Whether the prism is hot.\n   */\n  get isHot(): boolean {\n    return this._state.hot\n  }\n\n  onChange(\n    ticker: Ticker,\n    listener: (v: V) => void,\n    immediate: boolean = false,\n  ): VoidFn {\n    // the prism will call this function every time it goes from fresh to stale\n    const dependent = () => {\n      // schedule the listener to be called on the next tick, unless\n      // we're already on a tick, in which case it'll be called on the current tick.\n      ticker.onThisOrNextTick(refresh)\n    }\n\n    // let's cache the last value so we don't call the listener if the value hasn't changed\n    let lastValue =\n      // use an empty object as the initial value so that the listener is called on the first tick.\n      // if we were to use, say, undefined, and this.getValue() also returned undefined, the listener\n      // would never be called.\n      emptyObject\n\n    // this function will be _scheduled_ to be called on the currently running, or next tick,\n    // after the prism has gone from fresh to stale.\n    const refresh = () => {\n      const newValue = this.getValue()\n      // if the value hasn't changed, don't call the listener\n      if (newValue === lastValue) return\n\n      // the value has changed - cache it\n      lastValue = newValue\n\n      // and let the listener know\n      listener(newValue)\n    }\n\n    // add the dependent to the prism's list of dependents (which will make it go hot)\n    this._addDependent(dependent)\n\n    // if the caller wants the listener to be called immediately, call it now\n    if (immediate) {\n      lastValue = this.getValue()\n      listener(lastValue as $IntentionalAny as V)\n    }\n\n    // the unsubscribe function\n    const unsubscribe = () => {\n      // remove the dependent from the prism's list of dependents (and if it was the last dependent, the prism will go cold)\n      this._removeDependent(dependent)\n      // in case we're scheduled for a tick, cancel that\n      ticker.offThisOrNextTick(refresh)\n      ticker.offNextTick(refresh)\n    }\n\n    return unsubscribe\n  }\n\n  /**\n   * Calls `callback` every time the prism's state goes from `fresh-\\>stale.` Returns an `unsubscribe()` function.\n   */\n  onStale(callback: () => void): VoidFn {\n    const untap = () => {\n      this._removeDependent(fn)\n    }\n    const fn = () => callback()\n    this._addDependent(fn)\n    return untap\n  }\n\n  /**\n   * Keep the prism hot, even if there are no tappers (subscribers).\n   */\n  keepHot() {\n    return this.onStale(() => {})\n  }\n\n  /**\n   * Add a prism as a dependent of this prism.\n   *\n   * @param d - The prism to be made a dependent of this prism.\n   *\n   * @see _removeDependent\n   */\n  _addDependent(d: IDependent) {\n    if (!this._state.hot) {\n      this._goHot()\n    }\n    this._state.handle!.addDependent(d)\n  }\n\n  private _goHot() {\n    const hotHandle = new HotHandle(this._fn, this)\n    this._state = {\n      hot: true,\n      handle: hotHandle,\n    }\n  }\n\n  /**\n   * Remove a prism as a dependent of this prism.\n   *\n   * @param d - The prism to be removed from as a dependent of this prism.\n   *\n   * @see _addDependent\n   */\n  _removeDependent(d: IDependent) {\n    const state = this._state\n    if (!state.hot) {\n      return\n    }\n    const handle = state.handle\n    handle.removeDependent(d)\n    if (!handle.hasDependents) {\n      this._state = {hot: false, handle: undefined}\n      handle.destroy()\n    }\n  }\n\n  /**\n   * Gets the current value of the prism. If the value is stale, it causes the prism to freshen.\n   */\n  getValue(): V {\n    /**\n     * TODO We should prevent (or warn about) a common mistake users make, which is reading the value of\n     * a prism in the body of a react component (e.g. `der.getValue()` (often via `val()`) instead of `useVal()`\n     * or `uesPrism()`).\n     *\n     * Although that's the most common example of this mistake, you can also find it outside of react components.\n     * Basically the user runs `der.getValue()` assuming the read is detected by a wrapping prism when it's not.\n     *\n     * Sometiems the prism isn't even hot when the user assumes it is.\n     *\n     * We can fix this type of mistake by:\n     * 1. Warning the user when they call `getValue()` on a cold prism.\n     * 2. Warning the user about calling `getValue()` on a hot-but-stale prism\n     *    if `getValue()` isn't called by a known mechanism like a `PrismEmitter`.\n     *\n     * Design constraints:\n     * - This fix should not have a perf-penalty in production. Perhaps use a global flag + `process.env.NODE_ENV !== 'production'`\n     *   to enable it.\n     * - In the case of `onStale()`, we don't control when the user calls\n     *   `getValue()` (as opposed to `onChange()` which calls `getValue()` directly).\n     *   Perhaps we can disable the check in that case.\n     * - Probably the best place to add this check is right here in this method plus some changes to `reportResulutionStart()`,\n     *   which would have to be changed to let the caller know if there is an actual collector (a prism)\n     *   present in its stack.\n     */\n    reportResolutionStart(this)\n\n    const state = this._state\n\n    let val: V\n    if (state.hot) {\n      val = state.handle.getValue()\n    } else {\n      val = calculateColdPrism(this._fn)\n    }\n\n    reportResolutionEnd(this)\n    return val\n  }\n}\n\ninterface PrismScope {\n  effect(key: string, cb: () => () => void, deps?: unknown[]): void\n  memo<T>(\n    key: string,\n    fn: () => T,\n    deps: undefined | $IntentionalAny[] | ReadonlyArray<$IntentionalAny>,\n  ): T\n  state<T>(key: string, initialValue: T): [T, (val: T) => void]\n  ref<T>(key: string, initialValue: T): IRef<T>\n  sub(key: string): PrismScope\n  source<V>(subscribe: (fn: (val: V) => void) => VoidFn, getValue: () => V): V\n}\n\nclass HotScope implements PrismScope {\n  constructor(private readonly _hotHandle: HotHandle<unknown>) {}\n\n  protected readonly _refs: Map<string, IRef<unknown>> = new Map()\n  ref<T>(key: string, initialValue: T): IRef<T> {\n    let ref = this._refs.get(key)\n    if (ref !== undefined) {\n      return ref as $IntentionalAny as IRef<T>\n    } else {\n      const ref = {\n        current: initialValue,\n      }\n      this._refs.set(key, ref)\n      return ref\n    }\n  }\n  isPrismScope = true\n\n  // NOTE probably not a great idea to eager-allocate all of these objects/maps for every scope,\n  // especially because most wouldn't get used in the majority of cases. However, back when these\n  // were stored on weakmaps, they were uncomfortable to inspect in the debugger.\n  readonly subs: Record<string, HotScope> = {}\n  readonly effects: Map<string, IEffect> = new Map()\n\n  effect(key: string, cb: () => () => void, deps?: unknown[]): void {\n    let effect = this.effects.get(key)\n    if (effect === undefined) {\n      effect = {\n        cleanup: voidFn,\n        deps: undefined,\n      }\n      this.effects.set(key, effect)\n    }\n\n    if (depsHaveChanged(effect.deps, deps)) {\n      effect.cleanup()\n\n      startIgnoringDependencies()\n      effect.cleanup = safelyRun(cb, voidFn).value\n      stopIgnoringDependencies()\n      effect.deps = deps\n    }\n    /**\n     * TODO: we should cleanup dangling effects too.\n     * Example:\n     * ```ts\n     * let i = 0\n     * prism(() => {\n     *   if (i === 0) prism.effect(\"this effect will only run once\", () => {}, [])\n     *   i++\n     * })\n     * ```\n     */\n  }\n\n  readonly memos: Map<string, IMemo> = new Map()\n\n  memo<T>(\n    key: string,\n    fn: () => T,\n    deps: undefined | $IntentionalAny[] | ReadonlyArray<$IntentionalAny>,\n  ): T {\n    let memo = this.memos.get(key)\n    if (memo === undefined) {\n      memo = {\n        cachedValue: null,\n        // undefined will always indicate \"deps have changed\", so we set its initial value as such\n        deps: undefined,\n      }\n      this.memos.set(key, memo)\n    }\n\n    if (depsHaveChanged(memo.deps, deps)) {\n      startIgnoringDependencies()\n\n      memo.cachedValue = safelyRun(fn, undefined).value\n      stopIgnoringDependencies()\n      memo.deps = deps\n    }\n\n    return memo.cachedValue as $IntentionalAny as T\n  }\n\n  state<T>(key: string, initialValue: T): [T, (val: T) => void] {\n    const {value, setValue} = this.memo(\n      'state/' + key,\n      () => {\n        const value = {current: initialValue}\n        const setValue = (newValue: T) => {\n          value.current = newValue\n          this._hotHandle.forceStale()\n        }\n        return {value, setValue}\n      },\n      [],\n    )\n\n    return [value.current, setValue]\n  }\n\n  sub(key: string): HotScope {\n    if (!this.subs[key]) {\n      this.subs[key] = new HotScope(this._hotHandle)\n    }\n    return this.subs[key]\n  }\n\n  cleanupEffects() {\n    for (const effect of this.effects.values()) {\n      safelyRun(effect.cleanup, undefined)\n    }\n    this.effects.clear()\n  }\n\n  source<V>(subscribe: (fn: (val: V) => void) => VoidFn, getValue: () => V): V {\n    const sourceKey = '$$source/blah'\n    this.effect(\n      sourceKey,\n      () => {\n        const unsub = subscribe(() => {\n          this._hotHandle.forceStale()\n        })\n        return unsub\n      },\n      [subscribe],\n    )\n    return getValue()\n  }\n}\n\nfunction cleanupScopeStack(scope: HotScope) {\n  for (const sub of Object.values(scope.subs)) {\n    cleanupScopeStack(sub)\n  }\n  scope.cleanupEffects()\n}\n\nfunction safelyRun<T, U>(\n  fn: () => T,\n  returnValueInCaseOfError: U,\n): {ok: true; value: T} | {ok: false; value: U} {\n  try {\n    return {value: fn(), ok: true}\n  } catch (error) {\n    // Naming this function can allow the error reporter additional context to the user on where this error came from\n    setTimeout(function PrismReportThrow() {\n      // ensure that the error gets reported, but does not crash the current execution scope\n      throw error\n    })\n    return {value: returnValueInCaseOfError, ok: false}\n  }\n}\n\nconst hookScopeStack = new Stack<PrismScope>()\n\ntype IRef<T> = {\n  current: T\n}\n\ntype IEffect = {\n  deps: undefined | unknown[]\n  cleanup: VoidFn\n}\n\ntype IMemo = {\n  deps: undefined | unknown[] | ReadonlyArray<unknown>\n  cachedValue: unknown\n}\n\n/**\n * Just like React's `useRef()`, `prism.ref()` allows us to create a prism that holds a reference to some value.\n * The only difference is that `prism.ref()` requires a key to be passed into it, whlie `useRef()` doesn't.\n * This means that we can call `prism.ref()` in any order, and we can call it multiple times with the same key.\n * @param key - The key for the ref. Should be unique inside of the prism.\n * @param initialValue - The initial value for the ref.\n * @returns `{current: V}` - The ref object.\n *\n * Note that the ref object will always return its initial value if the prism is cold. It'll only record\n * its current value if the prism is hot (and will forget again if the prism goes cold again).\n *\n * @example\n * ```ts\n * const pr = prism(() => {\n *   const ref1 = prism.ref(\"ref1\", 0)\n *   console.log(ref1.current) // will print 0, and if the prism is hot, it'll print the current value\n *   ref1.current++ // changing the current value of the ref\n * })\n * ```\n */\nfunction ref<T>(key: string, initialValue: T): IRef<T> {\n  const scope = hookScopeStack.peek()\n  if (!scope) {\n    throw new Error(`prism.ref() is called outside of a prism() call.`)\n  }\n\n  return scope.ref(key, initialValue)\n}\n\n/**\n * An effect hook, similar to React's `useEffect()`, but is not sensitive to call order by using `key`.\n *\n * @param key - the key for the effect. Should be uniqe inside of the prism.\n * @param cb - the callback function. Requires returning a cleanup function.\n * @param deps - the dependency array\n */\nfunction effect(key: string, cb: () => () => void, deps?: unknown[]): void {\n  const scope = hookScopeStack.peek()\n  if (!scope) {\n    throw new Error(`prism.effect() is called outside of a prism() call.`)\n  }\n\n  return scope.effect(key, cb, deps)\n}\n\nfunction depsHaveChanged(\n  oldDeps: undefined | unknown[] | ReadonlyArray<unknown>,\n  newDeps: undefined | unknown[] | ReadonlyArray<unknown>,\n): boolean {\n  if (oldDeps === undefined || newDeps === undefined) {\n    return true\n  }\n\n  const len = oldDeps.length\n  if (len !== newDeps.length) return true\n\n  for (let i = 0; i < len; i++) {\n    if (oldDeps[i] !== newDeps[i]) return true\n  }\n\n  return false\n}\n\n/**\n * `prism.memo()` works just like React's `useMemo()` hook. It's a way to cache the result of a function call.\n * The only difference is that `prism.memo()` requires a key to be passed into it, whlie `useMemo()` doesn't.\n * This means that we can call `prism.memo()` in any order, and we can call it multiple times with the same key.\n *\n * @param key - The key for the memo. Should be unique inside of the prism\n * @param fn - The function to memoize\n * @param deps - The dependency array. Provide `[]` if you want to the value to be memoized only once and never re-calculated.\n * @returns The result of the function call\n *\n * @example\n * ```ts\n * const pr = prism(() => {\n *  const memoizedReturnValueOfExpensiveFn = prism.memo(\"memo1\", expensiveFn, [])\n * })\n * ```\n */\nfunction memo<T>(\n  key: string,\n  fn: () => T,\n  deps: undefined | $IntentionalAny[] | ReadonlyArray<$IntentionalAny>,\n): T {\n  const scope = hookScopeStack.peek()\n  if (!scope) {\n    throw new Error(`prism.memo() is called outside of a prism() call.`)\n  }\n\n  return scope.memo(key, fn, deps)\n}\n\n/**\n * A state hook, similar to react's `useState()`.\n *\n * @param key - the key for the state\n * @param initialValue - the initial value\n * @returns [currentState, setState]\n *\n * @example\n * ```ts\n * import {prism} from 'dataverse'\n *\n * // This prism holds the current mouse position and updates when the mouse moves\n * const mousePositionD = prism(() => {\n *   const [pos, setPos] = prism.state<[x: number, y: number]>('pos', [0, 0])\n *\n *   prism.effect(\n *     'setupListeners',\n *     () => {\n *       const handleMouseMove = (e: MouseEvent) => {\n *         setPos([e.screenX, e.screenY])\n *       }\n *       document.addEventListener('mousemove', handleMouseMove)\n *\n *       return () => {\n *         document.removeEventListener('mousemove', handleMouseMove)\n *       }\n *     },\n *     [],\n *   )\n *\n *   return pos\n * })\n * ```\n */\nfunction state<T>(key: string, initialValue: T): [T, (val: T) => void] {\n  const scope = hookScopeStack.peek()\n  if (!scope) {\n    throw new Error(`prism.state() is called outside of a prism() call.`)\n  }\n\n  return scope.state(key, initialValue)\n}\n\n/**\n * This is useful to make sure your code is running inside a `prism()` call.\n *\n * @example\n * ```ts\n * import {prism} from '@theatre/dataverse'\n *\n * function onlyUsefulInAPrism() {\n *   prism.ensurePrism()\n * }\n *\n * prism(() => {\n *   onlyUsefulInAPrism() // will run fine\n * })\n *\n * setTimeout(() => {\n *   onlyUsefulInAPrism() // throws an error\n *   console.log('This will never get logged')\n * }, 0)\n * ```\n */\nfunction ensurePrism(): void {\n  const scope = hookScopeStack.peek()\n  if (!scope) {\n    throw new Error(`The parent function is called outside of a prism() call.`)\n  }\n}\n\nfunction scope<T>(key: string, fn: () => T): T {\n  const parentScope = hookScopeStack.peek()\n  if (!parentScope) {\n    throw new Error(`prism.scope() is called outside of a prism() call.`)\n  }\n  const subScope = parentScope.sub(key)\n  hookScopeStack.push(subScope)\n  const ret = safelyRun(fn, undefined).value\n  hookScopeStack.pop()\n  return ret as $IntentionalAny as T\n}\n\n/**\n * Just an alias for `prism.memo(key, () => prism(fn), deps).getValue()`. It creates a new prism, memoizes it, and returns the value.\n * `prism.sub()` is useful when you want to divide your prism into smaller prisms, each of which\n * would _only_ recalculate when _certain_ dependencies change. In other words, it's an optimization tool.\n *\n * @param key - The key for the memo. Should be unique inside of the prism\n * @param fn - The function to run inside the prism\n * @param deps - The dependency array. Provide `[]` if you want to the value to be memoized only once and never re-calculated.\n * @returns The value of the inner prism\n */\nfunction sub<T>(\n  key: string,\n  fn: () => T,\n  deps: undefined | $IntentionalAny[],\n): T {\n  return memo(key, () => prism(fn), deps).getValue()\n}\n\n/**\n * @returns true if the current function is running inside a `prism()` call.\n */\nfunction inPrism(): boolean {\n  return !!hookScopeStack.peek()\n}\n\nconst possiblePrismToValue = <P extends Prism<$IntentionalAny> | unknown>(\n  input: P,\n): P extends Prism<infer T> ? T : P => {\n  if (isPrism(input)) {\n    return input.getValue() as $IntentionalAny\n  } else {\n    return input as $IntentionalAny\n  }\n}\n\n/**\n * `prism.source()`  allow a prism to react to changes in some external source (other than other prisms).\n * For example, `Atom.pointerToPrism()` uses `prism.source()` to create a prism that reacts to changes in the atom's value.\n \n * @param subscribe - The prism will call this function as soon as the prism goes hot. This function should return an unsubscribe function function which the prism will call when it goes cold.\n * @param getValue - A function that returns the current value of the external source.\n * @returns The current value of the source\n * \n * Example:\n * ```ts\n * function prismFromInputElement(input: HTMLInputElement): Prism<string> {\n *   function listen(cb: (value: string) => void) {\n *     const listener = () => {\n *       cb(input.value)\n *     }\n *     input.addEventListener('input', listener)\n *     return () => {\n *       input.removeEventListener('input', listener)\n *     }\n *   }\n *   \n *   function get() {\n *     return input.value\n *   }\n *   return prism(() => prism.source(listen, get))\n * }\n * ```\n */\nfunction source<V>(\n  subscribe: (fn: (val: V) => void) => VoidFn,\n  getValue: () => V,\n): V {\n  const scope = hookScopeStack.peek()\n  if (!scope) {\n    throw new Error(`prism.source() is called outside of a prism() call.`)\n  }\n\n  return scope.source(subscribe, getValue)\n}\n\ntype IPrismFn = {\n  <T>(fn: () => T): Prism<T>\n  ref: typeof ref\n  effect: typeof effect\n  memo: typeof memo\n  ensurePrism: typeof ensurePrism\n  state: typeof state\n  scope: typeof scope\n  sub: typeof sub\n  inPrism: typeof inPrism\n  source: typeof source\n}\n\n/**\n * Creates a prism from the passed function that adds all prisms referenced\n * in it as dependencies, and reruns the function when these change.\n *\n * @param fn - The function to rerun when the prisms referenced in it change.\n */\nconst prism: IPrismFn = (fn) => {\n  return new PrismInstance(fn)\n}\n\nclass ColdScope implements PrismScope {\n  effect(key: string, cb: () => () => void, deps?: unknown[]): void {\n    console.warn(`prism.effect() does not run in cold prisms`)\n  }\n  memo<T>(\n    key: string,\n    fn: () => T,\n    deps: any[] | readonly any[] | undefined,\n  ): T {\n    return fn()\n  }\n  state<T>(key: string, initialValue: T): [T, (val: T) => void] {\n    return [initialValue, () => {}]\n  }\n  ref<T>(key: string, initialValue: T): IRef<T> {\n    return {current: initialValue}\n  }\n  sub(key: string): ColdScope {\n    return new ColdScope()\n  }\n  source<V>(subscribe: (fn: (val: V) => void) => VoidFn, getValue: () => V): V {\n    return getValue()\n  }\n}\n\nfunction calculateColdPrism<V>(fn: () => V): V {\n  const scope = new ColdScope()\n  hookScopeStack.push(scope)\n  let value: V\n  try {\n    value = fn()\n  } catch (error) {\n    console.error(error)\n  } finally {\n    const topOfTheStack = hookScopeStack.pop()\n    if (topOfTheStack !== scope) {\n      console.warn(\n        // @todo guide the user to report the bug in an issue\n        `The Prism hook stack has slipped. This is a bug.`,\n      )\n    }\n  }\n  return value!\n}\n\nprism.ref = ref\nprism.effect = effect\nprism.memo = memo\nprism.ensurePrism = ensurePrism\nprism.state = state\nprism.scope = scope\nprism.sub = sub\nprism.inPrism = inPrism\nprism.source = source\n\nexport default prism\n","import get from 'lodash-es/get'\nimport isPlainObject from 'lodash-es/isPlainObject'\nimport last from 'lodash-es/last'\nimport type {Prism} from './prism/Interface'\nimport type {Pointer} from './pointer'\nimport {getPointerParts} from './pointer'\nimport {isPointer} from './pointer'\nimport pointer from './pointer'\nimport type {$FixMe, $IntentionalAny} from './types'\nimport updateDeep from './utils/updateDeep'\nimport prism from './prism/prism'\nimport type {PointerToPrismProvider} from './pointerToPrism'\n\ntype Listener = (newVal: unknown) => void\n\nenum ValueTypes {\n  Dict,\n  Array,\n  Other,\n}\n\nconst getTypeOfValue = (v: unknown): ValueTypes => {\n  if (Array.isArray(v)) return ValueTypes.Array\n  if (isPlainObject(v)) return ValueTypes.Dict\n  return ValueTypes.Other\n}\n\nconst getKeyOfValue = (\n  v: unknown,\n  key: string | number,\n  vType: ValueTypes = getTypeOfValue(v),\n): unknown => {\n  if (vType === ValueTypes.Dict && typeof key === 'string') {\n    return (v as $IntentionalAny)[key]\n  } else if (vType === ValueTypes.Array && isValidArrayIndex(key)) {\n    return (v as $IntentionalAny)[key]\n  } else {\n    return undefined\n  }\n}\n\nconst isValidArrayIndex = (key: string | number): boolean => {\n  const inNumber = typeof key === 'number' ? key : parseInt(key, 10)\n  return (\n    !isNaN(inNumber) &&\n    inNumber >= 0 &&\n    inNumber < Infinity &&\n    (inNumber | 0) === inNumber\n  )\n}\n\nclass Scope {\n  children: Map<string | number, Scope> = new Map()\n  identityChangeListeners: Set<Listener> = new Set()\n  constructor(\n    readonly _parent: undefined | Scope,\n    readonly _path: (string | number)[],\n  ) {}\n\n  addIdentityChangeListener(cb: Listener) {\n    this.identityChangeListeners.add(cb)\n  }\n\n  removeIdentityChangeListener(cb: Listener) {\n    this.identityChangeListeners.delete(cb)\n    this._checkForGC()\n  }\n\n  removeChild(key: string | number) {\n    this.children.delete(key)\n    this._checkForGC()\n  }\n\n  getChild(key: string | number) {\n    return this.children.get(key)\n  }\n\n  getOrCreateChild(key: string | number) {\n    let child = this.children.get(key)\n    if (!child) {\n      child = child = new Scope(this, this._path.concat([key]))\n      this.children.set(key, child)\n    }\n    return child\n  }\n\n  _checkForGC() {\n    if (this.identityChangeListeners.size > 0) return\n    if (this.children.size > 0) return\n\n    if (this._parent) {\n      this._parent.removeChild(last(this._path) as string | number)\n    }\n  }\n}\n\n/**\n * Wraps an object whose (sub)properties can be individually tracked.\n */\nexport default class Atom<State> implements PointerToPrismProvider {\n  private _currentState: State\n  /**\n   * @internal\n   */\n  readonly $$isPointerToPrismProvider = true\n  private readonly _rootScope: Scope\n  /**\n   * Convenience property that gives you a pointer to the root of the atom.\n   *\n   * @remarks\n   * Equivalent to `pointer({ root: thisAtom, path: [] })`.\n   */\n  readonly pointer: Pointer<State> = pointer({root: this as $FixMe, path: []})\n\n  readonly prism: Prism<State> = this.pointerToPrism(\n    this.pointer,\n  ) as $IntentionalAny\n\n  constructor(initialState: State) {\n    this._currentState = initialState\n    this._rootScope = new Scope(undefined, [])\n  }\n\n  /**\n   * Sets the state of the atom.\n   *\n   * @param newState - The new state of the atom.\n   */\n  set(newState: State) {\n    const oldState = this._currentState\n    this._currentState = newState\n\n    this._checkUpdates(this._rootScope, oldState, newState)\n  }\n\n  get(): State {\n    return this._currentState\n  }\n\n  /**\n   * Returns the value at the given pointer\n   *\n   * @param pointerOrFn - A pointer to the desired path. Could also be a function returning a pointer\n   *\n   * Example\n   * ```ts\n   * const atom = atom({ a: { b: 1 } })\n   * atom.getByPointer(atom.pointer.a.b) // 1\n   * atom.getByPointer((p) => p.a.b) // 1\n   * ```\n   */\n  getByPointer<S>(\n    pointerOrFn: Pointer<S> | ((p: Pointer<State>) => Pointer<S>),\n  ): S {\n    const pointer = isPointer(pointerOrFn)\n      ? pointerOrFn\n      : (pointerOrFn as $IntentionalAny)(this.pointer)\n\n    const path = getPointerParts(pointer).path\n    return this._getIn(path) as S\n  }\n\n  /**\n   * Gets the state of the atom at `path`.\n   */\n  private _getIn(path: (string | number)[]): unknown {\n    return path.length === 0 ? this.get() : get(this.get(), path)\n  }\n\n  reduce(fn: (state: State) => State) {\n    this.set(fn(this.get()))\n  }\n\n  /**\n   * Reduces the value at the given pointer\n   *\n   * @param pointerOrFn - A pointer to the desired path. Could also be a function returning a pointer\n   *\n   * Example\n   * ```ts\n   * const atom = atom({ a: { b: 1 } })\n   * atom.reduceByPointer(atom.pointer.a.b, (b) => b + 1) // atom.get().a.b === 2\n   * atom.reduceByPointer((p) => p.a.b, (b) => b + 1) // atom.get().a.b === 2\n   * ```\n   */\n  reduceByPointer<S>(\n    pointerOrFn: Pointer<S> | ((p: Pointer<State>) => Pointer<S>),\n    reducer: (s: S) => S,\n  ) {\n    const pointer = isPointer(pointerOrFn)\n      ? pointerOrFn\n      : (pointerOrFn as $IntentionalAny)(this.pointer)\n\n    const path = getPointerParts(pointer).path\n    const newState = updateDeep(this.get(), path, reducer)\n    this.set(newState)\n  }\n\n  /**\n   * Sets the value at the given pointer\n   *\n   * @param pointerOrFn - A pointer to the desired path. Could also be a function returning a pointer\n   *\n   * Example\n   * ```ts\n   * const atom = atom({ a: { b: 1 } })\n   * atom.setByPointer(atom.pointer.a.b, 2) // atom.get().a.b === 2\n   * atom.setByPointer((p) => p.a.b, 2) // atom.get().a.b === 2\n   * ```\n   */\n  setByPointer<S>(\n    pointerOrFn: Pointer<S> | ((p: Pointer<State>) => Pointer<S>),\n    val: S,\n  ) {\n    this.reduceByPointer(pointerOrFn, () => val)\n  }\n\n  private _checkUpdates(scope: Scope, oldState: unknown, newState: unknown) {\n    if (oldState === newState) return\n    for (const cb of scope.identityChangeListeners) {\n      cb(newState)\n    }\n\n    if (scope.children.size === 0) return\n\n    // @todo we can probably skip checking value types\n    const oldValueType = getTypeOfValue(oldState)\n    const newValueType = getTypeOfValue(newState)\n\n    if (oldValueType === ValueTypes.Other && oldValueType === newValueType)\n      return\n\n    for (const [childKey, childScope] of scope.children) {\n      const oldChildVal = getKeyOfValue(oldState, childKey, oldValueType)\n      const newChildVal = getKeyOfValue(newState, childKey, newValueType)\n      this._checkUpdates(childScope, oldChildVal, newChildVal)\n    }\n  }\n\n  private _getOrCreateScopeForPath(path: (string | number)[]): Scope {\n    let curScope = this._rootScope\n    for (const pathEl of path) {\n      curScope = curScope.getOrCreateChild(pathEl)\n    }\n    return curScope\n  }\n\n  private _onPointerValueChange = <P>(\n    pointer: Pointer<P>,\n    cb: (v: P) => void,\n  ): (() => void) => {\n    const {path} = getPointerParts(pointer)\n    const scope = this._getOrCreateScopeForPath(path)\n    scope.identityChangeListeners.add(cb as $IntentionalAny)\n    const unsubscribe = () => {\n      scope.identityChangeListeners.delete(cb as $IntentionalAny)\n    }\n    return unsubscribe\n  }\n\n  /**\n   * Returns a new prism of the value at the provided path.\n   *\n   * @param pointer - The path to create the prism at.\n   *\n   * ```ts\n   * const pr = atom({ a: { b: 1 } }).pointerToPrism(atom.pointer.a.b)\n   * pr.getValue() // 1\n   * ```\n   */\n  pointerToPrism<P>(pointer: Pointer<P>): Prism<P> {\n    const {path} = getPointerParts(pointer)\n    const subscribe = (listener: (val: unknown) => void) =>\n      this._onPointerValueChange(pointer, listener)\n\n    const getValue = () => this._getIn(path)\n\n    return prism(() => {\n      return prism.source(subscribe, getValue)\n    }) as Prism<P>\n  }\n}\n","import type {Prism} from './prism/Interface'\nimport type {Pointer, PointerType} from './pointer'\nimport {getPointerMeta} from './pointer'\nimport type {$IntentionalAny} from './types'\n\nconst identifyPrismWeakMap = new WeakMap<{}, Prism<unknown>>()\n\n/**\n * Interface for objects that can provide a prism at a certain path.\n */\nexport interface PointerToPrismProvider {\n  /**\n   * @internal\n   * Future: We could consider using a `Symbol.for(\"dataverse/PointerToPrismProvider\")` as a key here, similar to\n   * how {@link Iterable} works for `of`.\n   */\n  readonly $$isPointerToPrismProvider: true\n  /**\n   * Returns a prism of the value at the provided pointer.\n   */\n  pointerToPrism<P>(pointer: Pointer<P>): Prism<P>\n}\n\nexport function isPointerToPrismProvider(\n  val: unknown,\n): val is PointerToPrismProvider {\n  return (\n    typeof val === 'object' &&\n    val !== null &&\n    (val as $IntentionalAny)['$$isPointerToPrismProvider'] === true\n  )\n}\n\n/**\n * Returns a prism of the value at the provided pointer. Prisms are\n * cached per pointer.\n *\n * @param pointer - The pointer to return the prism at.\n */\n\nexport const pointerToPrism = <P extends PointerType<$IntentionalAny>>(\n  pointer: P,\n): Prism<P extends PointerType<infer T> ? T : void> => {\n  const meta = getPointerMeta(pointer)\n\n  let prismInstance = identifyPrismWeakMap.get(meta)\n  if (!prismInstance) {\n    const root = meta.root\n    if (!isPointerToPrismProvider(root)) {\n      throw new Error(\n        `Cannot run pointerToPrism() on a pointer whose root is not an PointerToPrismProvider`,\n      )\n    }\n    prismInstance = root.pointerToPrism(pointer as $IntentionalAny)\n    identifyPrismWeakMap.set(meta, prismInstance)\n  }\n  return prismInstance as $IntentionalAny\n}\n","import type {Prism} from './prism/Interface'\nimport {isPrism} from './prism/Interface'\nimport type {PointerType} from './pointer'\nimport {isPointer} from './pointer'\nimport type {$IntentionalAny} from './types'\nimport {pointerToPrism} from './pointerToPrism'\n\n/**\n * Convenience function that returns a plain value from its argument, whether it\n * is a pointer, a prism or a plain value itself.\n *\n * @remarks\n * For pointers, the value is returned by first creating a prism, so it is\n * reactive e.g. when used in a `prism`.\n *\n * @param input - The argument to return a value from.\n */\n\nexport const val = <\n  P extends\n    | PointerType<$IntentionalAny>\n    | Prism<$IntentionalAny>\n    | undefined\n    | null,\n>(\n  input: P,\n): P extends PointerType<infer T>\n  ? T\n  : P extends Prism<infer T>\n  ? T\n  : P extends undefined | null\n  ? P\n  : unknown => {\n  if (isPointer(input)) {\n    return pointerToPrism(input).getValue() as $IntentionalAny\n  } else if (isPrism(input)) {\n    return input.getValue() as $IntentionalAny\n  } else {\n    return input as $IntentionalAny\n  }\n}\n","import {pointerToPrism} from '../pointerToPrism'\nimport type {Pointer} from '../pointer'\nimport {isPointer} from '../pointer'\nimport type {Prism} from './Interface'\nimport {isPrism} from './Interface'\n\nexport default function* iterateAndCountTicks<V>(\n  pointerOrPrism: Prism<V> | Pointer<V>,\n): Generator<{value: V; ticks: number}, void, void> {\n  let d\n  if (isPointer(pointerOrPrism)) {\n    d = pointerToPrism(pointerOrPrism) as Prism<V>\n  } else if (isPrism(pointerOrPrism)) {\n    d = pointerOrPrism\n  } else {\n    throw new Error(`Only pointers and prisms are supported`)\n  }\n\n  let ticksCountedSinceLastYield = 0\n  const untap = d.onStale(() => {\n    ticksCountedSinceLastYield++\n  })\n\n  try {\n    while (true) {\n      const ticks = ticksCountedSinceLastYield\n      ticksCountedSinceLastYield = 0\n      yield {value: d.getValue(), ticks}\n    }\n  } finally {\n    untap()\n  }\n}\n","type ICallback = (t: number) => void\n\n/**\n * The number of ticks that can pass without any scheduled callbacks before the Ticker goes dormant. This is to prevent\n * the Ticker from staying active forever, even if there are no scheduled callbacks.\n *\n * Perhaps counting ticks vs. time is not the best way to do this. But it's a start.\n */\nexport const EMPTY_TICKS_BEFORE_GOING_DORMANT = 60 /*fps*/ * 3 /*seconds*/ // on a 60fps screen, 3 seconds should pass before the ticker goes dormant\n\n/**\n * The Ticker class helps schedule callbacks. Scheduled callbacks are executed per tick. Ticks can be triggered by an\n * external scheduling strategy, e.g. a raf.\n */\nexport default class Ticker {\n  private _scheduledForThisOrNextTick: Set<ICallback>\n  private _scheduledForNextTick: Set<ICallback>\n  private _timeAtCurrentTick: number\n  private _ticking: boolean = false\n\n  /**\n   * Whether the Ticker is dormant\n   */\n  private _dormant: boolean = true\n\n  private _numberOfDormantTicks = 0\n\n  /**\n   * Whether the Ticker is dormant\n   */\n  get dormant(): boolean {\n    return this._dormant\n  }\n  /**\n   * Counts up for every tick executed.\n   * Internally, this is used to measure ticks per second.\n   *\n   * This is \"public\" to TypeScript, because it's a tool for performance measurements.\n   * Consider this as experimental, and do not rely on it always being here in future releases.\n   */\n  public __ticks = 0\n\n  constructor(\n    private _conf?: {\n      /**\n       * This is called when the Ticker goes dormant.\n       */\n      onDormant?: () => void\n      /**\n       * This is called when the Ticker goes active.\n       */\n      onActive?: () => void\n    },\n  ) {\n    this._scheduledForThisOrNextTick = new Set()\n    this._scheduledForNextTick = new Set()\n    this._timeAtCurrentTick = 0\n  }\n\n  /**\n   * Registers for fn to be called either on this tick or the next tick.\n   *\n   * If `onThisOrNextTick()` is called while `Ticker.tick()` is running, the\n   * side effect _will_ be called within the running tick. If you don't want this\n   * behavior, you can use `onNextTick()`.\n   *\n   * Note that `fn` will be added to a `Set()`. Which means, if you call `onThisOrNextTick(fn)`\n   * with the same fn twice in a single tick, it'll only run once.\n   *\n   * @param fn - The function to be registered.\n   *\n   * @see offThisOrNextTick\n   */\n  onThisOrNextTick(fn: ICallback) {\n    this._scheduledForThisOrNextTick.add(fn)\n    if (this._dormant) {\n      this._goActive()\n    }\n  }\n\n  /**\n   * Registers a side effect to be called on the next tick.\n   *\n   * @param fn - The function to be registered.\n   *\n   * @see onThisOrNextTick\n   * @see offNextTick\n   */\n  onNextTick(fn: ICallback) {\n    this._scheduledForNextTick.add(fn)\n    if (this._dormant) {\n      this._goActive()\n    }\n  }\n\n  /**\n   * De-registers a fn to be called either on this tick or the next tick.\n   *\n   * @param fn - The function to be de-registered.\n   *\n   * @see onThisOrNextTick\n   */\n  offThisOrNextTick(fn: ICallback) {\n    this._scheduledForThisOrNextTick.delete(fn)\n  }\n\n  /**\n   * De-registers a fn to be called on the next tick.\n   *\n   * @param fn - The function to be de-registered.\n   *\n   * @see onNextTick\n   */\n  offNextTick(fn: ICallback) {\n    this._scheduledForNextTick.delete(fn)\n  }\n\n  /**\n   * The time at the start of the current tick if there is a tick in progress, otherwise defaults to\n   * `performance.now()`.\n   */\n  get time() {\n    if (this._ticking) {\n      return this._timeAtCurrentTick\n    } else return performance.now()\n  }\n\n  private _goActive() {\n    if (!this._dormant) return\n    this._dormant = false\n    this._conf?.onActive?.()\n  }\n\n  private _goDormant() {\n    if (this._dormant) return\n    this._dormant = true\n    this._numberOfDormantTicks = 0\n    this._conf?.onDormant?.()\n  }\n\n  /**\n   * Triggers a tick which starts executing the callbacks scheduled for this tick.\n   *\n   * @param t - The time at the tick.\n   *\n   * @see onThisOrNextTick\n   * @see onNextTick\n   */\n  tick(t: number = performance.now()) {\n    if (process.env.NODE_ENV === 'development') {\n      if (!(this instanceof Ticker)) {\n        throw new Error(\n          'ticker.tick must be called while bound to the ticker. As in, \"ticker.tick(time)\" or \"requestAnimationFrame((t) => ticker.tick(t))\" for performance.',\n        )\n      }\n    }\n\n    this.__ticks++\n\n    if (!this._dormant) {\n      if (\n        this._scheduledForNextTick.size === 0 &&\n        this._scheduledForThisOrNextTick.size === 0\n      ) {\n        this._numberOfDormantTicks++\n        if (this._numberOfDormantTicks >= EMPTY_TICKS_BEFORE_GOING_DORMANT) {\n          this._goDormant()\n          return\n        }\n      }\n    }\n\n    this._ticking = true\n    this._timeAtCurrentTick = t\n    for (const v of this._scheduledForNextTick) {\n      this._scheduledForThisOrNextTick.add(v)\n    }\n\n    this._scheduledForNextTick.clear()\n    this._tick(0)\n    this._ticking = false\n  }\n\n  private _tick(iterationNumber: number): void {\n    const time = this.time\n\n    if (iterationNumber > 10) {\n      console.warn('_tick() recursing for 10 times')\n    }\n\n    if (iterationNumber > 100) {\n      throw new Error(`Maximum recursion limit for _tick()`)\n    }\n\n    const oldSet = this._scheduledForThisOrNextTick\n    this._scheduledForThisOrNextTick = new Set()\n    for (const fn of oldSet) {\n      fn(time)\n    }\n\n    if (this._scheduledForThisOrNextTick.size > 0) {\n      return this._tick(iterationNumber + 1)\n    }\n  }\n}\n","import {pointerToPrism} from '../pointerToPrism'\nimport type {Pointer} from '../pointer'\nimport {isPointer} from '../pointer'\nimport Ticker from '../Ticker'\nimport type {Prism} from './Interface'\nimport {isPrism} from './Interface'\n\nexport default function* iterateOver<V>(\n  pointerOrPrism: Prism<V> | Pointer<V>,\n): Generator<V, void, void> {\n  let d\n  if (isPointer(pointerOrPrism)) {\n    d = pointerToPrism(pointerOrPrism) as Prism<V>\n  } else if (isPrism(pointerOrPrism)) {\n    d = pointerOrPrism\n  } else {\n    throw new Error(`Only pointers and prisms are supported`)\n  }\n\n  const ticker = new Ticker()\n\n  const untap = d.onChange(ticker, (v) => {})\n\n  try {\n    while (true) {\n      ticker.tick()\n\n      yield d.getValue()\n    }\n  } finally {\n    untap()\n  }\n}\n","import Atom from './Atom'\nimport {val} from './val'\nimport type {Pointer} from './pointer'\nimport {getPointerMeta} from './pointer'\nimport pointer from './pointer'\nimport type {$FixMe, $IntentionalAny} from './types'\nimport prism from './prism/prism'\nimport type {Prism} from './prism/Interface'\nimport type {PointerToPrismProvider} from './pointerToPrism'\n\n/**\n * Allows creating pointer-prisms where the pointer can be switched out.\n *\n * @remarks\n * This allows reacting not just to value changes at a certain pointer, but changes\n * to the proxied pointer too.\n */\nexport default class PointerProxy<O extends {}>\n  implements PointerToPrismProvider\n{\n  /**\n   * @internal\n   */\n  readonly $$isPointerToPrismProvider = true\n  private readonly _currentPointerBox: Atom<Pointer<O>>\n  /**\n   * Convenience pointer pointing to the root of this PointerProxy.\n   *\n   * @remarks\n   * Allows convenient use of {@link pointerToPrism} and {@link val}.\n   */\n  readonly pointer: Pointer<O>\n\n  constructor(currentPointer: Pointer<O>) {\n    this._currentPointerBox = new Atom(currentPointer)\n    this.pointer = pointer({root: this as $FixMe, path: []})\n  }\n\n  /**\n   * Sets the underlying pointer.\n   * @param p - The pointer to be proxied.\n   */\n  setPointer(p: Pointer<O>) {\n    this._currentPointerBox.set(p)\n  }\n\n  /**\n   * Returns a prism of the value at the provided sub-path of the proxied pointer.\n   *\n   * @param path - The path to create the prism at.\n   */\n  pointerToPrism<P>(pointer: Pointer<P>): Prism<P> {\n    const {path} = getPointerMeta(pointer)\n    return prism(() => {\n      const currentPointer = this._currentPointerBox.prism.getValue()\n      const subPointer = path.reduce(\n        (pointerSoFar, pathItem) => (pointerSoFar as $IntentionalAny)[pathItem],\n        currentPointer,\n      )\n      return val(subPointer) as P\n    })\n  }\n}\n"]},"metadata":{},"sourceType":"script"}