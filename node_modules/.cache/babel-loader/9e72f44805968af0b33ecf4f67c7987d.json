{"ast":null,"code":"// While filters are precompiled, pseudos get called when they are needed\nexport var pseudos = {\n  empty: function empty(elem, _ref) {\n    var adapter = _ref.adapter;\n    return !adapter.getChildren(elem).some(function (elem) {\n      return (\n        // FIXME: `getText` call is potentially expensive.\n        adapter.isTag(elem) || adapter.getText(elem) !== \"\"\n      );\n    });\n  },\n  \"first-child\": function firstChild(elem, _ref2) {\n    var adapter = _ref2.adapter,\n      equals = _ref2.equals;\n    if (adapter.prevElementSibling) {\n      return adapter.prevElementSibling(elem) == null;\n    }\n    var firstChild = adapter.getSiblings(elem).find(function (elem) {\n      return adapter.isTag(elem);\n    });\n    return firstChild != null && equals(elem, firstChild);\n  },\n  \"last-child\": function lastChild(elem, _ref3) {\n    var adapter = _ref3.adapter,\n      equals = _ref3.equals;\n    var siblings = adapter.getSiblings(elem);\n    for (var i = siblings.length - 1; i >= 0; i--) {\n      if (equals(elem, siblings[i])) return true;\n      if (adapter.isTag(siblings[i])) break;\n    }\n    return false;\n  },\n  \"first-of-type\": function firstOfType(elem, _ref4) {\n    var adapter = _ref4.adapter,\n      equals = _ref4.equals;\n    var siblings = adapter.getSiblings(elem);\n    var elemName = adapter.getName(elem);\n    for (var i = 0; i < siblings.length; i++) {\n      var currentSibling = siblings[i];\n      if (equals(elem, currentSibling)) return true;\n      if (adapter.isTag(currentSibling) && adapter.getName(currentSibling) === elemName) {\n        break;\n      }\n    }\n    return false;\n  },\n  \"last-of-type\": function lastOfType(elem, _ref5) {\n    var adapter = _ref5.adapter,\n      equals = _ref5.equals;\n    var siblings = adapter.getSiblings(elem);\n    var elemName = adapter.getName(elem);\n    for (var i = siblings.length - 1; i >= 0; i--) {\n      var currentSibling = siblings[i];\n      if (equals(elem, currentSibling)) return true;\n      if (adapter.isTag(currentSibling) && adapter.getName(currentSibling) === elemName) {\n        break;\n      }\n    }\n    return false;\n  },\n  \"only-of-type\": function onlyOfType(elem, _ref6) {\n    var adapter = _ref6.adapter,\n      equals = _ref6.equals;\n    var elemName = adapter.getName(elem);\n    return adapter.getSiblings(elem).every(function (sibling) {\n      return equals(elem, sibling) || !adapter.isTag(sibling) || adapter.getName(sibling) !== elemName;\n    });\n  },\n  \"only-child\": function onlyChild(elem, _ref7) {\n    var adapter = _ref7.adapter,\n      equals = _ref7.equals;\n    return adapter.getSiblings(elem).every(function (sibling) {\n      return equals(elem, sibling) || !adapter.isTag(sibling);\n    });\n  }\n};\nexport function verifyPseudoArgs(func, name, subselect, argIndex) {\n  if (subselect === null) {\n    if (func.length > argIndex) {\n      throw new Error(\"Pseudo-class :\".concat(name, \" requires an argument\"));\n    }\n  } else if (func.length === argIndex) {\n    throw new Error(\"Pseudo-class :\".concat(name, \" doesn't have any arguments\"));\n  }\n}","map":{"version":3,"sources":["pseudo-selectors/pseudos.ts"],"names":[],"mappings":"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","sourceRoot":"https://raw.githubusercontent.com/fb55/css-select/0f0725a9dfeddd2fdb54eda9656cdbab5bbf6be6/src/","sourcesContent":["// While filters are precompiled, pseudos get called when they are needed\nexport const pseudos = {\n    empty(elem, { adapter }) {\n        return !adapter.getChildren(elem).some((elem) => \n        // FIXME: `getText` call is potentially expensive.\n        adapter.isTag(elem) || adapter.getText(elem) !== \"\");\n    },\n    \"first-child\"(elem, { adapter, equals }) {\n        if (adapter.prevElementSibling) {\n            return adapter.prevElementSibling(elem) == null;\n        }\n        const firstChild = adapter\n            .getSiblings(elem)\n            .find((elem) => adapter.isTag(elem));\n        return firstChild != null && equals(elem, firstChild);\n    },\n    \"last-child\"(elem, { adapter, equals }) {\n        const siblings = adapter.getSiblings(elem);\n        for (let i = siblings.length - 1; i >= 0; i--) {\n            if (equals(elem, siblings[i]))\n                return true;\n            if (adapter.isTag(siblings[i]))\n                break;\n        }\n        return false;\n    },\n    \"first-of-type\"(elem, { adapter, equals }) {\n        const siblings = adapter.getSiblings(elem);\n        const elemName = adapter.getName(elem);\n        for (let i = 0; i < siblings.length; i++) {\n            const currentSibling = siblings[i];\n            if (equals(elem, currentSibling))\n                return true;\n            if (adapter.isTag(currentSibling) &&\n                adapter.getName(currentSibling) === elemName) {\n                break;\n            }\n        }\n        return false;\n    },\n    \"last-of-type\"(elem, { adapter, equals }) {\n        const siblings = adapter.getSiblings(elem);\n        const elemName = adapter.getName(elem);\n        for (let i = siblings.length - 1; i >= 0; i--) {\n            const currentSibling = siblings[i];\n            if (equals(elem, currentSibling))\n                return true;\n            if (adapter.isTag(currentSibling) &&\n                adapter.getName(currentSibling) === elemName) {\n                break;\n            }\n        }\n        return false;\n    },\n    \"only-of-type\"(elem, { adapter, equals }) {\n        const elemName = adapter.getName(elem);\n        return adapter\n            .getSiblings(elem)\n            .every((sibling) => equals(elem, sibling) ||\n            !adapter.isTag(sibling) ||\n            adapter.getName(sibling) !== elemName);\n    },\n    \"only-child\"(elem, { adapter, equals }) {\n        return adapter\n            .getSiblings(elem)\n            .every((sibling) => equals(elem, sibling) || !adapter.isTag(sibling));\n    },\n};\nexport function verifyPseudoArgs(func, name, subselect, argIndex) {\n    if (subselect === null) {\n        if (func.length > argIndex) {\n            throw new Error(`Pseudo-class :${name} requires an argument`);\n        }\n    }\n    else if (func.length === argIndex) {\n        throw new Error(`Pseudo-class :${name} doesn't have any arguments`);\n    }\n}\n//# sourceMappingURL=pseudos.js.map"]},"metadata":{},"sourceType":"module"}